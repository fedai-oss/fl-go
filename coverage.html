
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ishaileshpant/fl-go/api/federation.pb.go (0.0%)</option>
				
				<option value="file1">github.com/ishaileshpant/fl-go/api/federation_grpc.pb.go (0.0%)</option>
				
				<option value="file2">github.com/ishaileshpant/fl-go/cmd/aggregator/main.go (0.0%)</option>
				
				<option value="file3">github.com/ishaileshpant/fl-go/cmd/collaborator/main.go (0.0%)</option>
				
				<option value="file4">github.com/ishaileshpant/fl-go/cmd/fx/main.go (0.0%)</option>
				
				<option value="file5">github.com/ishaileshpant/fl-go/cmd/monitor/main.go (0.0%)</option>
				
				<option value="file6">github.com/ishaileshpant/fl-go/pkg/aggregator/aggregator.go (3.0%)</option>
				
				<option value="file7">github.com/ishaileshpant/fl-go/pkg/aggregator/algorithms.go (0.0%)</option>
				
				<option value="file8">github.com/ishaileshpant/fl-go/pkg/aggregator/modular_aggregator.go (0.0%)</option>
				
				<option value="file9">github.com/ishaileshpant/fl-go/pkg/cli/aggregator.go (0.0%)</option>
				
				<option value="file10">github.com/ishaileshpant/fl-go/pkg/cli/collaborator.go (0.0%)</option>
				
				<option value="file11">github.com/ishaileshpant/fl-go/pkg/cli/plan.go (0.0%)</option>
				
				<option value="file12">github.com/ishaileshpant/fl-go/pkg/collaborator/collaborator.go (0.0%)</option>
				
				<option value="file13">github.com/ishaileshpant/fl-go/pkg/federation/parser.go (0.0%)</option>
				
				<option value="file14">github.com/ishaileshpant/fl-go/pkg/monitoring/api.go (0.0%)</option>
				
				<option value="file15">github.com/ishaileshpant/fl-go/pkg/monitoring/auth.go (81.4%)</option>
				
				<option value="file16">github.com/ishaileshpant/fl-go/pkg/monitoring/hooks.go (0.0%)</option>
				
				<option value="file17">github.com/ishaileshpant/fl-go/pkg/monitoring/storage.go (0.0%)</option>
				
				<option value="file18">github.com/ishaileshpant/fl-go/pkg/monitoring/storage_interface.go (60.0%)</option>
				
				<option value="file19">github.com/ishaileshpant/fl-go/pkg/monitoring/storage_memory.go (73.6%)</option>
				
				<option value="file20">github.com/ishaileshpant/fl-go/pkg/monitoring/storage_postgres.go (0.0%)</option>
				
				<option value="file21">github.com/ishaileshpant/fl-go/pkg/monitoring/storage_redis.go (0.0%)</option>
				
				<option value="file22">github.com/ishaileshpant/fl-go/pkg/security/mtls.go (75.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.7
//         protoc        v5.29.3
// source: api/federation.proto

package api

import (
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"

        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type JoinRequest struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        CollaboratorId string                 `protobuf:"bytes,1,opt,name=collaborator_id,json=collaboratorId,proto3" json:"collaborator_id,omitempty"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *JoinRequest) Reset() <span class="cov0" title="0">{
        *x = JoinRequest{}
        mi := &amp;file_api_federation_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *JoinRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*JoinRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *JoinRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_federation_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use JoinRequest.ProtoReflect.Descriptor instead.
func (*JoinRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_federation_proto_rawDescGZIP(), []int{0}
}</span>

func (x *JoinRequest) GetCollaboratorId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CollaboratorId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type JoinResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        InitialModel  []byte                 `protobuf:"bytes,1,opt,name=initial_model,json=initialModel,proto3" json:"initial_model,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *JoinResponse) Reset() <span class="cov0" title="0">{
        *x = JoinResponse{}
        mi := &amp;file_api_federation_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *JoinResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*JoinResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *JoinResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_federation_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use JoinResponse.ProtoReflect.Descriptor instead.
func (*JoinResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_federation_proto_rawDescGZIP(), []int{1}
}</span>

func (x *JoinResponse) GetInitialModel() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.InitialModel
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ModelUpdate struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        CollaboratorId string                 `protobuf:"bytes,1,opt,name=collaborator_id,json=collaboratorId,proto3" json:"collaborator_id,omitempty"`
        ModelWeights   []byte                 `protobuf:"bytes,2,opt,name=model_weights,json=modelWeights,proto3" json:"model_weights,omitempty"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *ModelUpdate) Reset() <span class="cov0" title="0">{
        *x = ModelUpdate{}
        mi := &amp;file_api_federation_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ModelUpdate) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ModelUpdate) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ModelUpdate) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_federation_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ModelUpdate.ProtoReflect.Descriptor instead.
func (*ModelUpdate) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_federation_proto_rawDescGZIP(), []int{2}
}</span>

func (x *ModelUpdate) GetCollaboratorId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CollaboratorId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ModelUpdate) GetModelWeights() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ModelWeights
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Ack struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Ack) Reset() <span class="cov0" title="0">{
        *x = Ack{}
        mi := &amp;file_api_federation_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Ack) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Ack) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Ack) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_federation_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Ack.ProtoReflect.Descriptor instead.
func (*Ack) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_federation_proto_rawDescGZIP(), []int{3}
}</span>

func (x *Ack) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

type GetModelRequest struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        CollaboratorId string                 `protobuf:"bytes,1,opt,name=collaborator_id,json=collaboratorId,proto3" json:"collaborator_id,omitempty"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *GetModelRequest) Reset() <span class="cov0" title="0">{
        *x = GetModelRequest{}
        mi := &amp;file_api_federation_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetModelRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetModelRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetModelRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_federation_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetModelRequest.ProtoReflect.Descriptor instead.
func (*GetModelRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_federation_proto_rawDescGZIP(), []int{4}
}</span>

func (x *GetModelRequest) GetCollaboratorId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CollaboratorId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetModelResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ModelWeights  []byte                 `protobuf:"bytes,1,opt,name=model_weights,json=modelWeights,proto3" json:"model_weights,omitempty"`
        CurrentRound  int32                  `protobuf:"varint,2,opt,name=current_round,json=currentRound,proto3" json:"current_round,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetModelResponse) Reset() <span class="cov0" title="0">{
        *x = GetModelResponse{}
        mi := &amp;file_api_federation_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetModelResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetModelResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetModelResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_federation_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetModelResponse.ProtoReflect.Descriptor instead.
func (*GetModelResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_federation_proto_rawDescGZIP(), []int{5}
}</span>

func (x *GetModelResponse) GetModelWeights() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ModelWeights
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetModelResponse) GetCurrentRound() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CurrentRound
        }</span>
        <span class="cov0" title="0">return 0</span>
}

var File_api_federation_proto protoreflect.FileDescriptor

const file_api_federation_proto_rawDesc = "" +
        "\n" +
        "\x14api/federation.proto\x12\n" +
        "federation\"6\n" +
        "\vJoinRequest\x12'\n" +
        "\x0fcollaborator_id\x18\x01 \x01(\tR\x0ecollaboratorId\"3\n" +
        "\fJoinResponse\x12#\n" +
        "\rinitial_model\x18\x01 \x01(\fR\finitialModel\"[\n" +
        "\vModelUpdate\x12'\n" +
        "\x0fcollaborator_id\x18\x01 \x01(\tR\x0ecollaboratorId\x12#\n" +
        "\rmodel_weights\x18\x02 \x01(\fR\fmodelWeights\"\x1f\n" +
        "\x03Ack\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\":\n" +
        "\x0fGetModelRequest\x12'\n" +
        "\x0fcollaborator_id\x18\x01 \x01(\tR\x0ecollaboratorId\"\\\n" +
        "\x10GetModelResponse\x12#\n" +
        "\rmodel_weights\x18\x01 \x01(\fR\fmodelWeights\x12#\n" +
        "\rcurrent_round\x18\x02 \x01(\x05R\fcurrentRound2\xdf\x01\n" +
        "\x11FederatedLearning\x12C\n" +
        "\x0eJoinFederation\x12\x17.federation.JoinRequest\x1a\x18.federation.JoinResponse\x128\n" +
        "\fSubmitUpdate\x12\x17.federation.ModelUpdate\x1a\x0f.federation.Ack\x12K\n" +
        "\x0eGetLatestModel\x12\x1b.federation.GetModelRequest\x1a\x1c.federation.GetModelResponseB\aZ\x05./apib\x06proto3"

var (
        file_api_federation_proto_rawDescOnce sync.Once
        file_api_federation_proto_rawDescData []byte
)

func file_api_federation_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_api_federation_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_api_federation_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_api_federation_proto_rawDesc), len(file_api_federation_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_api_federation_proto_rawDescData</span>
}

var file_api_federation_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_api_federation_proto_goTypes = []any{
        (*JoinRequest)(nil),      // 0: federation.JoinRequest
        (*JoinResponse)(nil),     // 1: federation.JoinResponse
        (*ModelUpdate)(nil),      // 2: federation.ModelUpdate
        (*Ack)(nil),              // 3: federation.Ack
        (*GetModelRequest)(nil),  // 4: federation.GetModelRequest
        (*GetModelResponse)(nil), // 5: federation.GetModelResponse
}
var file_api_federation_proto_depIdxs = []int32{
        0, // 0: federation.FederatedLearning.JoinFederation:input_type -&gt; federation.JoinRequest
        2, // 1: federation.FederatedLearning.SubmitUpdate:input_type -&gt; federation.ModelUpdate
        4, // 2: federation.FederatedLearning.GetLatestModel:input_type -&gt; federation.GetModelRequest
        1, // 3: federation.FederatedLearning.JoinFederation:output_type -&gt; federation.JoinResponse
        3, // 4: federation.FederatedLearning.SubmitUpdate:output_type -&gt; federation.Ack
        5, // 5: federation.FederatedLearning.GetLatestModel:output_type -&gt; federation.GetModelResponse
        3, // [3:6] is the sub-list for method output_type
        0, // [0:3] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_api_federation_proto_init() }</span>
func file_api_federation_proto_init() <span class="cov0" title="0">{
        if File_api_federation_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_api_federation_proto_rawDesc), len(file_api_federation_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   6,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_api_federation_proto_goTypes,
                DependencyIndexes: file_api_federation_proto_depIdxs,
                MessageInfos:      file_api_federation_proto_msgTypes,
        }.Build()
        File_api_federation_proto = out.File
        file_api_federation_proto_goTypes = nil
        file_api_federation_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: api/federation.proto

package api

import (
        context "context"

        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        FederatedLearning_JoinFederation_FullMethodName = "/federation.FederatedLearning/JoinFederation"
        FederatedLearning_SubmitUpdate_FullMethodName   = "/federation.FederatedLearning/SubmitUpdate"
        FederatedLearning_GetLatestModel_FullMethodName = "/federation.FederatedLearning/GetLatestModel"
)

// FederatedLearningClient is the client API for FederatedLearning service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FederatedLearningClient interface {
        JoinFederation(ctx context.Context, in *JoinRequest, opts ...grpc.CallOption) (*JoinResponse, error)
        SubmitUpdate(ctx context.Context, in *ModelUpdate, opts ...grpc.CallOption) (*Ack, error)
        GetLatestModel(ctx context.Context, in *GetModelRequest, opts ...grpc.CallOption) (*GetModelResponse, error)
}

type federatedLearningClient struct {
        cc grpc.ClientConnInterface
}

func NewFederatedLearningClient(cc grpc.ClientConnInterface) FederatedLearningClient <span class="cov0" title="0">{
        return &amp;federatedLearningClient{cc}
}</span>

func (c *federatedLearningClient) JoinFederation(ctx context.Context, in *JoinRequest, opts ...grpc.CallOption) (*JoinResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(JoinResponse)
        err := c.cc.Invoke(ctx, FederatedLearning_JoinFederation_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *federatedLearningClient) SubmitUpdate(ctx context.Context, in *ModelUpdate, opts ...grpc.CallOption) (*Ack, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(Ack)
        err := c.cc.Invoke(ctx, FederatedLearning_SubmitUpdate_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *federatedLearningClient) GetLatestModel(ctx context.Context, in *GetModelRequest, opts ...grpc.CallOption) (*GetModelResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetModelResponse)
        err := c.cc.Invoke(ctx, FederatedLearning_GetLatestModel_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// FederatedLearningServer is the server API for FederatedLearning service.
// All implementations must embed UnimplementedFederatedLearningServer
// for forward compatibility.
type FederatedLearningServer interface {
        JoinFederation(context.Context, *JoinRequest) (*JoinResponse, error)
        SubmitUpdate(context.Context, *ModelUpdate) (*Ack, error)
        GetLatestModel(context.Context, *GetModelRequest) (*GetModelResponse, error)
        mustEmbedUnimplementedFederatedLearningServer()
}

// UnimplementedFederatedLearningServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFederatedLearningServer struct{}

func (UnimplementedFederatedLearningServer) JoinFederation(context.Context, *JoinRequest) (*JoinResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method JoinFederation not implemented")
}</span>
func (UnimplementedFederatedLearningServer) SubmitUpdate(context.Context, *ModelUpdate) (*Ack, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SubmitUpdate not implemented")
}</span>
func (UnimplementedFederatedLearningServer) GetLatestModel(context.Context, *GetModelRequest) (*GetModelResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetLatestModel not implemented")
}</span>
func (UnimplementedFederatedLearningServer) mustEmbedUnimplementedFederatedLearningServer() {<span class="cov0" title="0">}</span>
func (UnimplementedFederatedLearningServer) testEmbeddedByValue()                           {<span class="cov0" title="0">}</span>

// UnsafeFederatedLearningServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FederatedLearningServer will
// result in compilation errors.
type UnsafeFederatedLearningServer interface {
        mustEmbedUnimplementedFederatedLearningServer()
}

func RegisterFederatedLearningServer(s grpc.ServiceRegistrar, srv FederatedLearningServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedFederatedLearningServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;FederatedLearning_ServiceDesc, srv)</span>
}

func _FederatedLearning_JoinFederation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(JoinRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(FederatedLearningServer).JoinFederation(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: FederatedLearning_JoinFederation_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(FederatedLearningServer).JoinFederation(ctx, req.(*JoinRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _FederatedLearning_SubmitUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ModelUpdate)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(FederatedLearningServer).SubmitUpdate(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: FederatedLearning_SubmitUpdate_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(FederatedLearningServer).SubmitUpdate(ctx, req.(*ModelUpdate))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _FederatedLearning_GetLatestModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetModelRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(FederatedLearningServer).GetLatestModel(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: FederatedLearning_GetLatestModel_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(FederatedLearningServer).GetLatestModel(ctx, req.(*GetModelRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// FederatedLearning_ServiceDesc is the grpc.ServiceDesc for FederatedLearning service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FederatedLearning_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "federation.FederatedLearning",
        HandlerType: (*FederatedLearningServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "JoinFederation",
                        Handler:    _FederatedLearning_JoinFederation_Handler,
                },
                {
                        MethodName: "SubmitUpdate",
                        Handler:    _FederatedLearning_SubmitUpdate_Handler,
                },
                {
                        MethodName: "GetLatestModel",
                        Handler:    _FederatedLearning_GetLatestModel_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "api/federation.proto",
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "log"

        "github.com/ishaileshpant/fl-go/pkg/aggregator"
        "github.com/ishaileshpant/fl-go/pkg/federation"
)

func main() <span class="cov0" title="0">{
        log.Println("Loading federated learning plan...")
        plan, err := federation.LoadPlan("plans/example_plan.yaml")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load plan: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Creating aggregator...")
        agg := aggregator.NewFedAvgAggregator(plan)

        log.Println("Starting aggregator...")
        if err := agg.Start(context.Background()); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Aggregator failed: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Aggregator completed successfully!")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "flag"
        "log"

        "github.com/ishaileshpant/fl-go/pkg/collaborator"
        "github.com/ishaileshpant/fl-go/pkg/federation"
)

func main() <span class="cov0" title="0">{
        id := flag.String("id", "collab1", "ID")
        plan := flag.String("plan", "plans/example_plan.yaml", "Plan path")
        flag.Parse()

        pl, err := federation.LoadPlan(*plan)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">c := collaborator.NewCollaborator(pl, *id)
        if err := c.Connect(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to aggregator: %v", err)
        }</span>

        <span class="cov0" title="0">update, err := c.RunTrainTask(pl.Tasks.Train)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to run training task: %v", err)
        }</span>

        <span class="cov0" title="0">if err := c.SubmitUpdate(update); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to submit update: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "fmt"
        "log"
        "os"

        "github.com/ishaileshpant/fl-go/pkg/cli"
)

func main() <span class="cov0" title="0">{
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                printUsage()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">command := os.Args[1]
        args := os.Args[2:]

        switch command </span>{
        case "plan":<span class="cov0" title="0">
                if err := cli.HandlePlanCommand(args); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Plan command failed: %v", err)
                }</span>
        case "aggregator":<span class="cov0" title="0">
                if err := cli.HandleAggregatorCommand(args); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Aggregator command failed: %v", err)
                }</span>
        case "collaborator":<span class="cov0" title="0">
                if err := cli.HandleCollaboratorCommand(args); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Collaborator command failed: %v", err)
                }</span>
        case "version":<span class="cov0" title="0">
                fmt.Println("FL-Go v1.0.0")</span>
        case "help", "--help", "-h":<span class="cov0" title="0">
                printUsage()</span>
        default:<span class="cov0" title="0">
                fmt.Printf("Unknown command: %s\n\n", command)
                printUsage()
                os.Exit(1)</span>
        }
}

func printUsage() <span class="cov0" title="0">{
        fmt.Println("FL-Go - A Go implementation of OpenFL")
        fmt.Println()
        fmt.Println("Usage:")
        fmt.Println("  fx &lt;command&gt; [arguments]")
        fmt.Println()
        fmt.Println("Available Commands:")
        fmt.Println("  plan         Manage federated learning plans")
        fmt.Println("  aggregator   Start and manage aggregator")
        fmt.Println("  collaborator Start and manage collaborator")
        fmt.Println("  version      Show version information")
        fmt.Println("  help         Show this help message")
        fmt.Println()
        fmt.Println("Examples:")
        fmt.Println("  fx plan init                    # Initialize a new FL workspace")
        fmt.Println("  fx aggregator start             # Start the aggregator")
        fmt.Println("  fx collaborator start collab1  # Start collaborator with ID 'collab1'")
        fmt.Println()
        fmt.Println("For more help on a specific command:")
        fmt.Println("  fx &lt;command&gt; --help")
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "log"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/ishaileshpant/fl-go/pkg/monitoring"
        "gopkg.in/yaml.v2"
)

func main() <span class="cov0" title="0">{
        var (
                configPath = flag.String("config", "monitoring_config.yaml", "Path to monitoring configuration file")
                port       = flag.Int("port", 8080, "API server port")
                webPort    = flag.Int("web-port", 3000, "Web UI port")
        )
        flag.Parse()

        // Load configuration
        config, err := loadConfig(*configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to load config, using defaults: %v", err)
                config = &amp;monitoring.MonitoringConfig{
                        Enabled:               true,
                        APIPort:               *port,
                        WebUIPort:             *webPort,
                        MetricsRetention:      24 * time.Hour,
                        CollectionInterval:    30 * time.Second,
                        EnableResourceMetrics: true,
                        EnableRealTimeEvents:  true,
                        StorageBackend:        "memory",
                }
        }</span>

        // Override with command line arguments
        <span class="cov0" title="0">if *port != 8080 </span><span class="cov0" title="0">{
                config.APIPort = *port
        }</span>
        <span class="cov0" title="0">if *webPort != 3000 </span><span class="cov0" title="0">{
                config.WebUIPort = *webPort
        }</span>

        <span class="cov0" title="0">log.Printf("Starting FL Monitoring Server")
        log.Printf("API Port: %d", config.APIPort)
        log.Printf("Web UI Port: %d", config.WebUIPort)
        log.Printf("Storage Backend: %s", config.StorageBackend)

        // Create storage backend
        var storage monitoring.MonitoringService
        switch config.StorageBackend </span>{
        case "memory":<span class="cov0" title="0">
                storage = monitoring.NewMemoryStorage(config)</span>
        default:<span class="cov0" title="0">
                log.Fatalf("Unsupported storage backend: %s", config.StorageBackend)</span>
        }

        // Create API server
        <span class="cov0" title="0">apiServer := monitoring.NewAPIServer(storage, config)

        // Start resource monitoring if enabled
        if config.EnableResourceMetrics </span><span class="cov0" title="0">{
                go startResourceMonitoring(storage, config)
        }</span>

        // Create sample data for demonstration
        <span class="cov0" title="0">if err := createSampleData(storage); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create sample data: %v", err)
        }</span>

        // Setup graceful shutdown
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Handle shutdown signals
        sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                &lt;-sigCh
                log.Println("Shutting down...")
                cancel()
        }</span>()

        // Start API server
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                if err := apiServer.Start(); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("API server failed: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">log.Println("FL Monitoring Server started successfully")
        log.Printf("API available at: http://localhost:%d/api/v1", config.APIPort)
        log.Printf("Health check: http://localhost:%d/api/v1/health", config.APIPort)
        log.Printf("Web UI will be available at: http://localhost:%d", config.WebUIPort)

        // Wait for shutdown signal
        &lt;-ctx.Done()
        log.Println("FL Monitoring Server stopped")</span>
}

// loadConfig loads monitoring configuration from file
func loadConfig(configPath string) (*monitoring.MonitoringConfig, error) <span class="cov0" title="0">{
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var config monitoring.MonitoringConfig
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

// startResourceMonitoring starts a goroutine to collect system resource metrics
func startResourceMonitoring(storage monitoring.MonitoringService, config *monitoring.MonitoringConfig) <span class="cov0" title="0">{
        ticker := time.NewTicker(config.CollectionInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Collect and record resource metrics for the monitoring server itself
                        ctx := context.Background()

                        // Simulate resource metrics collection
                        // In a real implementation, you would use system calls or libraries to get actual metrics
                        cpuUsage := 15.5                             // Percentage
                        memoryUsage := 42.8                          // Percentage
                        diskUsage := 67.2                            // Percentage
                        memoryUsed := int64(1024 * 1024 * 512)       // 512MB
                        memoryTotal := int64(1024 * 1024 * 1024 * 4) // 4GB
                        networkRx := 1.2                             // Mbps
                        networkTx := 0.8                             // Mbps

                        metrics := &amp;monitoring.ResourceMetrics{
                                Timestamp:     time.Now(),
                                CPUUsage:      cpuUsage,
                                MemoryUsage:   memoryUsage,
                                MemoryUsed:    memoryUsed,
                                MemoryTotal:   memoryTotal,
                                DiskUsage:     diskUsage,
                                NetworkRxRate: networkRx,
                                NetworkTxRate: networkTx,
                        }

                        if err := storage.RecordResourceMetrics(ctx, "monitoring-server", metrics); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to record resource metrics: %v", err)
                        }</span>
                }
        }
}

// createSampleData creates some sample monitoring data for demonstration
func createSampleData(storage monitoring.MonitoringService) error <span class="cov0" title="0">{
        ctx := context.Background()

        // Create sample federation
        federation := &amp;monitoring.FederationMetrics{
                ID:                "fed_demo_001",
                Name:              "Demo Federation",
                Status:            monitoring.StatusRunning,
                Mode:              "async",
                Algorithm:         "fedavg",
                StartTime:         time.Now().Add(-2 * time.Hour),
                CurrentRound:      5,
                TotalRounds:       10,
                ActiveCollabs:     3,
                TotalCollabs:      5,
                ModelSize:         1024000,
                LastUpdate:        time.Now().Add(-5 * time.Minute),
                AggregatorAddress: "localhost:8000",
        }

        if err := storage.RegisterFederation(ctx, federation); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create sample collaborators
        <span class="cov0" title="0">collaborators := []*monitoring.CollaboratorMetrics{
                {
                        ID:               "collab_001",
                        FederationID:     "fed_demo_001",
                        Address:          "192.168.1.100:8001",
                        Status:           monitoring.CollabStatusConnected,
                        JoinTime:         time.Now().Add(-2 * time.Hour),
                        LastSeen:         time.Now().Add(-2 * time.Minute),
                        CurrentRound:     5,
                        UpdatesSubmitted: 5,
                        TrainingTime:     45 * time.Minute,
                        AverageLatency:   250.5,
                        ErrorCount:       0,
                },
                {
                        ID:               "collab_002",
                        FederationID:     "fed_demo_001",
                        Address:          "192.168.1.101:8001",
                        Status:           monitoring.CollabStatusTraining,
                        JoinTime:         time.Now().Add(-2 * time.Hour),
                        LastSeen:         time.Now().Add(-1 * time.Minute),
                        CurrentRound:     5,
                        UpdatesSubmitted: 4,
                        TrainingTime:     42 * time.Minute,
                        AverageLatency:   380.2,
                        ErrorCount:       1,
                        LastError:        "Connection timeout",
                },
                {
                        ID:               "collab_003",
                        FederationID:     "fed_demo_001",
                        Address:          "192.168.1.102:8001",
                        Status:           monitoring.CollabStatusConnected,
                        JoinTime:         time.Now().Add(-90 * time.Minute),
                        LastSeen:         time.Now().Add(-30 * time.Second),
                        CurrentRound:     5,
                        UpdatesSubmitted: 3,
                        TrainingTime:     28 * time.Minute,
                        AverageLatency:   195.8,
                        ErrorCount:       0,
                },
        }

        for _, collaborator := range collaborators </span><span class="cov0" title="0">{
                if err := storage.RegisterCollaborator(ctx, collaborator); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Create sample rounds
        <span class="cov0" title="0">for i := 1; i &lt;= 5; i++ </span><span class="cov0" title="0">{
                startTime := time.Now().Add(-time.Duration(6-i) * 20 * time.Minute)
                endTime := startTime.Add(15 * time.Minute)

                round := &amp;monitoring.RoundMetrics{
                        ID:               fmt.Sprintf("round_fed_demo_001_%d", i),
                        FederationID:     "fed_demo_001",
                        RoundNumber:      i,
                        Algorithm:        "fedavg",
                        StartTime:        startTime,
                        EndTime:          &amp;endTime,
                        Duration:         15 * time.Minute,
                        ParticipantCount: 3,
                        UpdatesReceived:  3,
                        AggregationTime:  2 * time.Minute,
                        Status:           "completed",
                }

                // Add some accuracy progression
                accuracy := 0.65 + float64(i)*0.05
                loss := 0.8 - float64(i)*0.08
                round.ModelAccuracy = &amp;accuracy
                round.ModelLoss = &amp;loss

                if err := storage.RecordRoundStart(ctx, round); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := storage.RecordRoundEnd(ctx, round.ID, round); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Create sample model updates
        <span class="cov0" title="0">for i := 1; i &lt;= 5; i++ </span><span class="cov0" title="0">{
                for j, collabID := range []string{"collab_001", "collab_002", "collab_003"} </span><span class="cov0" title="0">{
                        if i == 2 &amp;&amp; j == 1 </span><span class="cov0" title="0">{
                                continue</span> // Simulate collab_002 missing round 2
                        }

                        <span class="cov0" title="0">update := &amp;monitoring.ModelUpdateMetrics{
                                FederationID:   "fed_demo_001",
                                CollaboratorID: collabID,
                                RoundNumber:    i,
                                Timestamp:      time.Now().Add(-time.Duration(6-i) * 20 * time.Minute),
                                UpdateSize:     1024000 + j*50000,
                                ProcessingTime: 150.0 + float64(j*50),
                                Staleness:      0,
                                Weight:         1.0,
                        }

                        if err := storage.RecordModelUpdate(ctx, update); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        // Create sample events
        <span class="cov0" title="0">events := []*monitoring.MonitoringEvent{
                {
                        FederationID: "fed_demo_001",
                        Type:         monitoring.MetricTypeRound,
                        Timestamp:    time.Now().Add(-10 * time.Minute),
                        Source:       "aggregator",
                        Level:        "info",
                        Message:      "Round 5 completed successfully",
                        Data: map[string]interface{}{
                                "round":        5,
                                "participants": 3,
                                "duration_ms":  900000,
                        },
                },
                {
                        FederationID: "fed_demo_001",
                        Type:         monitoring.MetricTypeCollaborator,
                        Timestamp:    time.Now().Add(-15 * time.Minute),
                        Source:       "collab_002",
                        Level:        "warning",
                        Message:      "Connection timeout during model update",
                        Data: map[string]interface{}{
                                "timeout_ms":  5000,
                                "retry_count": 1,
                        },
                },
                {
                        FederationID: "fed_demo_001",
                        Type:         monitoring.MetricTypeAggregation,
                        Timestamp:    time.Now().Add(-20 * time.Minute),
                        Source:       "aggregator",
                        Level:        "info",
                        Message:      "Model aggregation completed",
                        Data: map[string]interface{}{
                                "algorithm":   "fedavg",
                                "updates":     3,
                                "convergence": 0.15,
                        },
                },
        }

        for _, event := range events </span><span class="cov0" title="0">{
                if err := storage.RecordEvent(ctx, event); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">log.Println("Sample monitoring data created successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package aggregator

import (
        "context"
        "encoding/binary"
        "fmt"
        "log"
        "math"
        "net"
        "os"
        "sync"
        "time"

        pb "github.com/ishaileshpant/fl-go/api"
        "github.com/ishaileshpant/fl-go/pkg/federation"
        "github.com/ishaileshpant/fl-go/pkg/security"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

// Aggregator interface defines the contract for both sync and async aggregators
type Aggregator interface {
        Start(ctx context.Context) error
        JoinFederation(ctx context.Context, req *pb.JoinRequest) (*pb.JoinResponse, error)
        SubmitUpdate(ctx context.Context, upd *pb.ModelUpdate) (*pb.Ack, error)
        GetLatestModel(ctx context.Context, req *pb.GetModelRequest) (*pb.GetModelResponse, error)
}

// UpdateInfo tracks update metadata for async FL
type UpdateInfo struct {
        CollaboratorID string
        Weights        []float32
        Timestamp      time.Time
        Round          int
        Staleness      int
}

// FedAvgAggregator implements synchronous multi-round FedAvg (existing implementation)
type FedAvgAggregator struct {
        pb.UnimplementedFederatedLearningServer
        plan         *federation.FLPlan
        mu           sync.Mutex
        updates      [][]float32
        modelSize    int
        currentRound int
        srv          *grpc.Server
}

// AsyncFedAvgAggregator implements asynchronous FedAvg based on Papaya paper
type AsyncFedAvgAggregator struct {
        pb.UnimplementedFederatedLearningServer
        plan         *federation.FLPlan
        mu           sync.Mutex
        updates      []UpdateInfo
        modelSize    int
        currentRound int
        srv          *grpc.Server
        globalModel  []float32
        lastUpdate   time.Time
        stopChan     chan struct{}
}

// NewAggregator creates the appropriate aggregator based on mode and algorithm
func NewAggregator(plan *federation.FLPlan) Aggregator <span class="cov8" title="1">{
        // Check if a specific algorithm is requested
        if plan.Algorithm.Name != "" &amp;&amp; plan.Algorithm.Name != "fedavg" </span><span class="cov0" title="0">{
                // Use modular aggregator for advanced algorithms
                modularAgg, err := NewModularAggregator(plan)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to create modular aggregator: %v, falling back to FedAvg", err)
                        // Fall back to default
                }</span> else<span class="cov0" title="0"> {
                        return modularAgg
                }</span>
        }

        // Default behavior: use legacy aggregators for FedAvg
        <span class="cov8" title="1">switch plan.Mode </span>{
        case federation.ModeAsync:<span class="cov8" title="1">
                return NewAsyncFedAvgAggregator(plan)</span>
        default:<span class="cov8" title="1">
                return NewFedAvgAggregator(plan)</span>
        }
}

func NewFedAvgAggregator(plan *federation.FLPlan) *FedAvgAggregator <span class="cov8" title="1">{
        return &amp;FedAvgAggregator{plan: plan}
}</span>

func NewAsyncFedAvgAggregator(plan *federation.FLPlan) *AsyncFedAvgAggregator <span class="cov8" title="1">{
        return &amp;AsyncFedAvgAggregator{
                plan:     plan,
                stopChan: make(chan struct{}),
        }
}</span>

// Synchronous Aggregator Implementation (existing)
func (a *FedAvgAggregator) Start(ctx context.Context) error <span class="cov0" title="0">{
        log.Printf("Starting SYNC aggregator on %s", a.plan.Aggregator.Address)
        log.Printf("Expecting %d collaborators for %d rounds", len(a.plan.Collaborators), a.plan.Rounds)

        lis, err := net.Listen("tcp", a.plan.Aggregator.Address)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Initialize TLS manager for secure communication
        <span class="cov0" title="0">tlsManager, err := security.NewTLSManager(security.TLSConfig(a.plan.Security.TLS), "certs")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize TLS manager: %w", err)
        }</span>

        // Get server options with TLS support
        <span class="cov0" title="0">serverOpts, err := tlsManager.NewServerOptions()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get server options: %w", err)
        }</span>

        // Fallback to insecure credentials if TLS is not enabled
        <span class="cov0" title="0">if len(serverOpts) == 0 </span><span class="cov0" title="0">{
                serverOpts = []grpc.ServerOption{grpc.Creds(insecure.NewCredentials())}
        }</span>

        <span class="cov0" title="0">a.srv = grpc.NewServer(serverOpts...)
        pb.RegisterFederatedLearningServer(a.srv, a)

        // Start gRPC server in background
        go func() </span><span class="cov0" title="0">{
                log.Printf("gRPC server listening on %s", a.plan.Aggregator.Address)
                if err := a.srv.Serve(lis); err != nil </span><span class="cov0" title="0">{
                        log.Printf("gRPC server error: %v", err)
                }</span>
        }()

        // Read initial model to determine size
        <span class="cov0" title="0">data, err := os.ReadFile(a.plan.InitialModel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">a.modelSize = len(data) / 4
        log.Printf("Model size: %d parameters", a.modelSize)

        // Run federated learning for specified rounds
        for round := 1; round &lt;= a.plan.Rounds; round++ </span><span class="cov0" title="0">{
                a.currentRound = round
                log.Printf("Starting round %d/%d", round, a.plan.Rounds)

                // Reset updates for new round
                a.mu.Lock()
                a.updates = make([][]float32, 0)
                a.mu.Unlock()

                // Wait for all collaborators to submit updates
                log.Printf("Waiting for %d collaborators to submit updates...", len(a.plan.Collaborators))
                for </span><span class="cov0" title="0">{
                        a.mu.Lock()
                        updateCount := len(a.updates)
                        a.mu.Unlock()

                        if updateCount &gt;= len(a.plan.Collaborators) </span><span class="cov0" title="0">{
                                log.Printf("Received updates from all %d collaborators", updateCount)
                                break</span>
                        }

                        <span class="cov0" title="0">log.Printf("Received %d/%d updates, waiting...", updateCount, len(a.plan.Collaborators))
                        time.Sleep(2 * time.Second)</span> // Check every 2 seconds
                }

                // Aggregate the updates
                <span class="cov0" title="0">log.Printf("Aggregating updates for round %d", round)
                avg := make([]float32, a.modelSize)
                a.mu.Lock()
                for _, upd := range a.updates </span><span class="cov0" title="0">{
                        for i, v := range upd </span><span class="cov0" title="0">{
                                avg[i] += v
                        }</span>
                }
                <span class="cov0" title="0">a.mu.Unlock()

                for i := range avg </span><span class="cov0" title="0">{
                        avg[i] /= float32(len(a.updates))
                }</span>

                // Save aggregated model
                <span class="cov0" title="0">buf := make([]byte, 4*a.modelSize)
                for i, v := range avg </span><span class="cov0" title="0">{
                        binary.LittleEndian.PutUint32(buf[i*4:], math.Float32bits(v))
                }</span>

                <span class="cov0" title="0">outputPath := a.plan.OutputModel
                if round &lt; a.plan.Rounds </span><span class="cov0" title="0">{
                        // For intermediate rounds, save to save directory
                        outputPath = fmt.Sprintf("save/round_%d_model.pt", round)
                }</span>

                <span class="cov0" title="0">if err := os.WriteFile(outputPath, buf, 0600); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">log.Printf("Round %d complete, model saved to %s", round, outputPath)</span>
        }

        <span class="cov0" title="0">log.Printf("All %d rounds completed successfully", a.plan.Rounds)
        a.srv.Stop()
        return nil</span>
}

func (a *FedAvgAggregator) JoinFederation(ctx context.Context, req *pb.JoinRequest) (*pb.JoinResponse, error) <span class="cov0" title="0">{
        log.Printf("Collaborator %s joining federation", req.CollaboratorId)
        data, err := os.ReadFile(a.plan.InitialModel)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not read initial model %s: %v", a.plan.InitialModel, err)
                // Return empty model if file doesn't exist
                return &amp;pb.JoinResponse{InitialModel: []byte{}}, nil
        }</span>
        <span class="cov0" title="0">return &amp;pb.JoinResponse{InitialModel: data}, nil</span>
}

func (a *FedAvgAggregator) SubmitUpdate(ctx context.Context, upd *pb.ModelUpdate) (*pb.Ack, error) <span class="cov0" title="0">{
        floats := make([]float32, len(upd.ModelWeights)/4)
        for i := range floats </span><span class="cov0" title="0">{
                floats[i] = math.Float32frombits(binary.LittleEndian.Uint32(upd.ModelWeights[i*4:]))
        }</span>
        <span class="cov0" title="0">a.mu.Lock()
        a.updates = append(a.updates, floats)
        updateCount := len(a.updates)
        a.mu.Unlock()

        log.Printf("Received update %d/%d for round %d", updateCount, len(a.plan.Collaborators), a.currentRound)
        return &amp;pb.Ack{Success: true}, nil</span>
}

func (a *FedAvgAggregator) GetLatestModel(ctx context.Context, req *pb.GetModelRequest) (*pb.GetModelResponse, error) <span class="cov0" title="0">{
        // In sync mode, return the initial model since rounds are synchronized
        data, err := os.ReadFile(a.plan.InitialModel)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read initial model: %v", err)
        }</span>

        // Safely convert int to int32 to prevent overflow
        <span class="cov0" title="0">var currentRound int32
        if a.currentRound &gt; math.MaxInt32 </span><span class="cov0" title="0">{
                log.Printf("Warning: current round %d exceeds int32 max, capping at %d", a.currentRound, math.MaxInt32)
                currentRound = math.MaxInt32
        }</span> else<span class="cov0" title="0"> {
                currentRound = int32(a.currentRound) // #nosec G115 - Safe conversion with bounds check above
        }</span>

        <span class="cov0" title="0">return &amp;pb.GetModelResponse{
                ModelWeights: data,
                CurrentRound: currentRound,
        }, nil</span>
}

// Asynchronous Aggregator Implementation (new)
func (a *AsyncFedAvgAggregator) Start(ctx context.Context) error <span class="cov0" title="0">{
        log.Printf("Starting ASYNC aggregator on %s", a.plan.Aggregator.Address)
        log.Printf("Async config: max_staleness=%d, min_updates=%d, delay=%ds",
                a.plan.AsyncConfig.MaxStaleness, a.plan.AsyncConfig.MinUpdates, a.plan.AsyncConfig.AggregationDelay)

        lis, err := net.Listen("tcp", a.plan.Aggregator.Address)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Initialize TLS manager for secure communication
        <span class="cov0" title="0">tlsManager, err := security.NewTLSManager(security.TLSConfig(a.plan.Security.TLS), "certs")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize TLS manager: %w", err)
        }</span>

        // Get server options with TLS support
        <span class="cov0" title="0">serverOpts, err := tlsManager.NewServerOptions()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get server options: %w", err)
        }</span>

        // Fallback to insecure credentials if TLS is not enabled
        <span class="cov0" title="0">if len(serverOpts) == 0 </span><span class="cov0" title="0">{
                serverOpts = []grpc.ServerOption{grpc.Creds(insecure.NewCredentials())}
        }</span>

        <span class="cov0" title="0">a.srv = grpc.NewServer(serverOpts...)
        pb.RegisterFederatedLearningServer(a.srv, a)

        // Start gRPC server in background
        go func() </span><span class="cov0" title="0">{
                log.Printf("gRPC server listening on %s", a.plan.Aggregator.Address)
                if err := a.srv.Serve(lis); err != nil </span><span class="cov0" title="0">{
                        log.Printf("gRPC server error: %v", err)
                }</span>
        }()

        // Read initial model to determine size and set as global model
        <span class="cov0" title="0">data, err := os.ReadFile(a.plan.InitialModel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">a.modelSize = len(data) / 4
        a.globalModel = make([]float32, a.modelSize)
        for i := range a.globalModel </span><span class="cov0" title="0">{
                a.globalModel[i] = math.Float32frombits(binary.LittleEndian.Uint32(data[i*4:]))
        }</span>
        <span class="cov0" title="0">log.Printf("Model size: %d parameters", a.modelSize)

        // Start async aggregation loop
        go a.asyncAggregationLoop()

        // Wait for completion signal (could be based on time, rounds, or other criteria)
        &lt;-ctx.Done()

        log.Printf("Async FL completed")
        a.srv.Stop()
        return nil</span>
}

func (a *AsyncFedAvgAggregator) asyncAggregationLoop() <span class="cov0" title="0">{
        ticker := time.NewTicker(time.Duration(a.plan.AsyncConfig.AggregationDelay) * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        a.mu.Lock()
                        updateCount := len(a.updates)
                        a.mu.Unlock()

                        if updateCount &gt;= a.plan.AsyncConfig.MinUpdates </span><span class="cov0" title="0">{
                                a.performAsyncAggregation()
                        }</span>
                case &lt;-a.stopChan:<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (a *AsyncFedAvgAggregator) performAsyncAggregation() <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()

        if len(a.updates) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">log.Printf("Performing async aggregation with %d updates", len(a.updates))

        // Calculate staleness for each update
        currentTime := time.Now()
        for i := range a.updates </span><span class="cov0" title="0">{
                a.updates[i].Staleness = int(currentTime.Sub(a.updates[i].Timestamp).Seconds())
        }</span>

        // Filter out updates that are too stale
        <span class="cov0" title="0">validUpdates := make([]UpdateInfo, 0)
        for _, update := range a.updates </span><span class="cov0" title="0">{
                if update.Staleness &lt;= a.plan.AsyncConfig.MaxStaleness </span><span class="cov0" title="0">{
                        validUpdates = append(validUpdates, update)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Dropping stale update from %s (staleness: %d)",
                                update.CollaboratorID, update.Staleness)
                }</span>
        }

        <span class="cov0" title="0">if len(validUpdates) == 0 </span><span class="cov0" title="0">{
                log.Printf("No valid updates to aggregate")
                return
        }</span>

        // Perform staleness-aware aggregation
        <span class="cov0" title="0">newModel := make([]float32, a.modelSize)
        totalWeight := 0.0

        for _, update := range validUpdates </span><span class="cov0" title="0">{
                // Apply staleness weight decay
                weight := math.Pow(a.plan.AsyncConfig.StalenessWeight, float64(update.Staleness))
                totalWeight += weight

                for i, v := range update.Weights </span><span class="cov0" title="0">{
                        newModel[i] += float32(weight) * v
                }</span>
        }

        // Normalize by total weight
        <span class="cov0" title="0">for i := range newModel </span><span class="cov0" title="0">{
                newModel[i] /= float32(totalWeight)
        }</span>

        // Update global model
        <span class="cov0" title="0">a.globalModel = newModel
        a.currentRound++
        a.lastUpdate = currentTime

        // Save updated model
        buf := make([]byte, 4*a.modelSize)
        for i, v := range a.globalModel </span><span class="cov0" title="0">{
                binary.LittleEndian.PutUint32(buf[i*4:], math.Float32bits(v))
        }</span>

        <span class="cov0" title="0">outputPath := fmt.Sprintf("save/async_round_%d_model.pt", a.currentRound)
        if err := os.WriteFile(outputPath, buf, 0600); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error saving async model: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Async round %d complete, model saved to %s", a.currentRound, outputPath)
        }</span>

        // Clear processed updates
        <span class="cov0" title="0">a.updates = make([]UpdateInfo, 0)</span>
}

func (a *AsyncFedAvgAggregator) JoinFederation(ctx context.Context, req *pb.JoinRequest) (*pb.JoinResponse, error) <span class="cov0" title="0">{
        log.Printf("Collaborator %s joining async federation", req.CollaboratorId)

        // Return current global model
        buf := make([]byte, 4*a.modelSize)
        for i, v := range a.globalModel </span><span class="cov0" title="0">{
                binary.LittleEndian.PutUint32(buf[i*4:], math.Float32bits(v))
        }</span>

        <span class="cov0" title="0">return &amp;pb.JoinResponse{InitialModel: buf}, nil</span>
}

func (a *AsyncFedAvgAggregator) SubmitUpdate(ctx context.Context, upd *pb.ModelUpdate) (*pb.Ack, error) <span class="cov0" title="0">{
        floats := make([]float32, len(upd.ModelWeights)/4)
        for i := range floats </span><span class="cov0" title="0">{
                floats[i] = math.Float32frombits(binary.LittleEndian.Uint32(upd.ModelWeights[i*4:]))
        }</span>

        <span class="cov0" title="0">updateInfo := UpdateInfo{
                CollaboratorID: upd.CollaboratorId,
                Weights:        floats,
                Timestamp:      time.Now(),
                Round:          a.currentRound,
        }

        a.mu.Lock()
        a.updates = append(a.updates, updateInfo)
        updateCount := len(a.updates)
        a.mu.Unlock()

        log.Printf("Received async update %d from %s (round %d)", updateCount, upd.CollaboratorId, a.currentRound)
        return &amp;pb.Ack{Success: true}, nil</span>
}

func (a *AsyncFedAvgAggregator) GetLatestModel(ctx context.Context, req *pb.GetModelRequest) (*pb.GetModelResponse, error) <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()

        // Return current global model
        buf := make([]byte, 4*a.modelSize)
        for i, v := range a.globalModel </span><span class="cov0" title="0">{
                binary.LittleEndian.PutUint32(buf[i*4:], math.Float32bits(v))
        }</span>

        <span class="cov0" title="0">log.Printf("Providing latest model to %s (round %d)", req.CollaboratorId, a.currentRound)

        // Safely convert int to int32 to prevent overflow
        var currentRound int32
        if a.currentRound &gt; math.MaxInt32 </span><span class="cov0" title="0">{
                log.Printf("Warning: current round %d exceeds int32 max, capping at %d", a.currentRound, math.MaxInt32)
                currentRound = math.MaxInt32
        }</span> else<span class="cov0" title="0"> {
                currentRound = int32(a.currentRound) // #nosec G115 - Safe conversion with bounds check above
        }</span>

        <span class="cov0" title="0">return &amp;pb.GetModelResponse{
                ModelWeights: buf,
                CurrentRound: currentRound,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package aggregator

import (
        "fmt"
        "math"
        "time"

        "github.com/ishaileshpant/fl-go/pkg/federation"
)

// AggregationAlgorithm defines the interface for all aggregation algorithms
type AggregationAlgorithm interface {
        // Initialize sets up the algorithm with configuration
        Initialize(config AlgorithmConfig) error

        // Aggregate performs the aggregation of client updates
        Aggregate(updates []ClientUpdate, globalModel []float32) ([]float32, error)

        // GetName returns the algorithm name
        GetName() string

        // GetHyperparameters returns algorithm-specific hyperparameters
        GetHyperparameters() map[string]interface{}

        // UpdateHyperparameters allows dynamic updates to hyperparameters
        UpdateHyperparameters(params map[string]interface{}) error
}

// ClientUpdate represents an update from a collaborator
type ClientUpdate struct {
        CollaboratorID string
        Weights        []float32
        Timestamp      time.Time
        Round          int
        Staleness      int
        NumSamples     int     // Number of training samples (for weighted aggregation)
        LearningRate   float32 // Client learning rate (for adaptive algorithms)
}

// AlgorithmConfig contains configuration for aggregation algorithms
type AlgorithmConfig struct {
        AlgorithmName   string                 `yaml:"algorithm"` // fedavg, fedopt, fedprox
        ModelSize       int                    `yaml:"model_size"`
        Hyperparameters map[string]interface{} `yaml:"hyperparameters"`
        Mode            federation.FLMode      `yaml:"mode"` // sync or async
}

// AlgorithmType represents supported aggregation algorithms
type AlgorithmType string

const (
        FedAvg  AlgorithmType = "fedavg"
        FedOpt  AlgorithmType = "fedopt"
        FedProx AlgorithmType = "fedprox"
)

// CreateAggregationAlgorithm creates an instance of the specified algorithm
func CreateAggregationAlgorithm(algType AlgorithmType) (AggregationAlgorithm, error) <span class="cov0" title="0">{
        switch algType </span>{
        case FedAvg:<span class="cov0" title="0">
                return &amp;FedAvgAlgorithm{}, nil</span>
        case FedOpt:<span class="cov0" title="0">
                return &amp;FedOptAlgorithm{}, nil</span>
        case FedProx:<span class="cov0" title="0">
                return &amp;FedProxAlgorithm{}, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported aggregation algorithm: %s", algType)</span>
        }
}

// =============================================================================
// FedAvg Algorithm (Vanilla Federated Averaging)
// =============================================================================

type FedAvgAlgorithm struct {
        name      string
        modelSize int
}

func (f *FedAvgAlgorithm) Initialize(config AlgorithmConfig) error <span class="cov0" title="0">{
        f.name = "FedAvg"
        f.modelSize = config.ModelSize
        return nil
}</span>

func (f *FedAvgAlgorithm) GetName() string <span class="cov0" title="0">{
        return f.name
}</span>

func (f *FedAvgAlgorithm) GetHyperparameters() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "algorithm":   "fedavg",
                "description": "Vanilla Federated Averaging",
        }
}</span>

func (f *FedAvgAlgorithm) UpdateHyperparameters(params map[string]interface{}) error <span class="cov0" title="0">{
        // FedAvg has no hyperparameters to update
        return nil
}</span>

func (f *FedAvgAlgorithm) Aggregate(updates []ClientUpdate, globalModel []float32) ([]float32, error) <span class="cov0" title="0">{
        if len(updates) == 0 </span><span class="cov0" title="0">{
                return globalModel, fmt.Errorf("no updates to aggregate")
        }</span>

        // Simple averaging
        <span class="cov0" title="0">aggregated := make([]float32, f.modelSize)
        totalSamples := 0

        // Calculate total samples for weighted averaging
        for _, update := range updates </span><span class="cov0" title="0">{
                totalSamples += update.NumSamples
        }</span>

        // Weighted aggregation based on number of samples
        <span class="cov0" title="0">for _, update := range updates </span><span class="cov0" title="0">{
                weight := float32(update.NumSamples) / float32(totalSamples)
                if totalSamples == 0 </span><span class="cov0" title="0">{
                        weight = 1.0 / float32(len(updates)) // Equal weighting if no sample info
                }</span>

                <span class="cov0" title="0">for i, v := range update.Weights </span><span class="cov0" title="0">{
                        if i &lt; len(aggregated) </span><span class="cov0" title="0">{
                                aggregated[i] += weight * v
                        }</span>
                }
        }

        <span class="cov0" title="0">return aggregated, nil</span>
}

// =============================================================================
// FedOpt Algorithm (Adaptive Server Optimization)
// Reference: "Adaptive Federated Optimization" (Reddi et al., 2020)
// =============================================================================

type FedOptAlgorithm struct {
        name      string
        modelSize int
        serverLR  float32
        beta1     float32
        beta2     float32
        epsilon   float32
        momentum  []float32 // First moment estimate
        velocity  []float32 // Second moment estimate
        round     int
}

func (f *FedOptAlgorithm) Initialize(config AlgorithmConfig) error <span class="cov0" title="0">{
        f.name = "FedOpt"
        f.modelSize = config.ModelSize

        // Default hyperparameters
        f.serverLR = 1.0
        f.beta1 = 0.9
        f.beta2 = 0.999
        f.epsilon = 1e-7
        f.round = 0

        // Initialize server optimizer state
        f.momentum = make([]float32, f.modelSize)
        f.velocity = make([]float32, f.modelSize)

        // Override with custom hyperparameters if provided
        if params := config.Hyperparameters; params != nil </span><span class="cov0" title="0">{
                if lr, ok := params["server_learning_rate"].(float64); ok </span><span class="cov0" title="0">{
                        f.serverLR = float32(lr)
                }</span>
                <span class="cov0" title="0">if beta1, ok := params["beta1"].(float64); ok </span><span class="cov0" title="0">{
                        f.beta1 = float32(beta1)
                }</span>
                <span class="cov0" title="0">if beta2, ok := params["beta2"].(float64); ok </span><span class="cov0" title="0">{
                        f.beta2 = float32(beta2)
                }</span>
                <span class="cov0" title="0">if eps, ok := params["epsilon"].(float64); ok </span><span class="cov0" title="0">{
                        f.epsilon = float32(eps)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (f *FedOptAlgorithm) GetName() string <span class="cov0" title="0">{
        return f.name
}</span>

func (f *FedOptAlgorithm) GetHyperparameters() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "algorithm":            "fedopt",
                "server_learning_rate": f.serverLR,
                "beta1":                f.beta1,
                "beta2":                f.beta2,
                "epsilon":              f.epsilon,
                "description":          "Adaptive Server Optimization (Adam-like)",
        }
}</span>

func (f *FedOptAlgorithm) UpdateHyperparameters(params map[string]interface{}) error <span class="cov0" title="0">{
        if lr, ok := params["server_learning_rate"].(float64); ok </span><span class="cov0" title="0">{
                f.serverLR = float32(lr)
        }</span>
        <span class="cov0" title="0">if beta1, ok := params["beta1"].(float64); ok </span><span class="cov0" title="0">{
                f.beta1 = float32(beta1)
        }</span>
        <span class="cov0" title="0">if beta2, ok := params["beta2"].(float64); ok </span><span class="cov0" title="0">{
                f.beta2 = float32(beta2)
        }</span>
        <span class="cov0" title="0">if eps, ok := params["epsilon"].(float64); ok </span><span class="cov0" title="0">{
                f.epsilon = float32(eps)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (f *FedOptAlgorithm) Aggregate(updates []ClientUpdate, globalModel []float32) ([]float32, error) <span class="cov0" title="0">{
        if len(updates) == 0 </span><span class="cov0" title="0">{
                return globalModel, fmt.Errorf("no updates to aggregate")
        }</span>

        <span class="cov0" title="0">f.round++

        // First, compute the pseudo-gradient (difference from global model)
        pseudoGradient := make([]float32, f.modelSize)
        totalSamples := 0

        // Calculate total samples for weighted averaging
        for _, update := range updates </span><span class="cov0" title="0">{
                totalSamples += update.NumSamples
        }</span>

        // Compute weighted average of client updates
        <span class="cov0" title="0">clientAverage := make([]float32, f.modelSize)
        for _, update := range updates </span><span class="cov0" title="0">{
                weight := float32(update.NumSamples) / float32(totalSamples)
                if totalSamples == 0 </span><span class="cov0" title="0">{
                        weight = 1.0 / float32(len(updates))
                }</span>

                <span class="cov0" title="0">for i, v := range update.Weights </span><span class="cov0" title="0">{
                        if i &lt; len(clientAverage) </span><span class="cov0" title="0">{
                                clientAverage[i] += weight * v
                        }</span>
                }
        }

        // Compute pseudo-gradient: difference between client average and global model
        <span class="cov0" title="0">for i := 0; i &lt; f.modelSize &amp;&amp; i &lt; len(globalModel); i++ </span><span class="cov0" title="0">{
                pseudoGradient[i] = clientAverage[i] - globalModel[i]
        }</span>

        // Apply Adam-like server optimization
        <span class="cov0" title="0">newModel := make([]float32, f.modelSize)
        copy(newModel, globalModel)

        for i := 0; i &lt; f.modelSize; i++ </span><span class="cov0" title="0">{
                // Update momentum (first moment estimate)
                f.momentum[i] = f.beta1*f.momentum[i] + (1-f.beta1)*pseudoGradient[i]

                // Update velocity (second moment estimate)
                f.velocity[i] = f.beta2*f.velocity[i] + (1-f.beta2)*pseudoGradient[i]*pseudoGradient[i]

                // Bias correction
                momentumCorrected := f.momentum[i] / (1 - float32(math.Pow(float64(f.beta1), float64(f.round))))
                velocityCorrected := f.velocity[i] / (1 - float32(math.Pow(float64(f.beta2), float64(f.round))))

                // Apply Adam update
                if i &lt; len(newModel) </span><span class="cov0" title="0">{
                        newModel[i] += f.serverLR * momentumCorrected / (float32(math.Sqrt(float64(velocityCorrected))) + f.epsilon)
                }</span>
        }

        <span class="cov0" title="0">return newModel, nil</span>
}

// =============================================================================
// FedProx Algorithm (Federated Optimization with Proximal Term)
// Reference: "Federated Optimization in Heterogeneous Networks" (Li et al., 2020)
// =============================================================================

type FedProxAlgorithm struct {
        name      string
        modelSize int
        mu        float32 // Proximal term coefficient
}

func (f *FedProxAlgorithm) Initialize(config AlgorithmConfig) error <span class="cov0" title="0">{
        f.name = "FedProx"
        f.modelSize = config.ModelSize
        f.mu = 0.01 // Default proximal term

        // Override with custom hyperparameters if provided
        if params := config.Hyperparameters; params != nil </span><span class="cov0" title="0">{
                if mu, ok := params["mu"].(float64); ok </span><span class="cov0" title="0">{
                        f.mu = float32(mu)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (f *FedProxAlgorithm) GetName() string <span class="cov0" title="0">{
        return f.name
}</span>

func (f *FedProxAlgorithm) GetHyperparameters() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "algorithm":   "fedprox",
                "mu":          f.mu,
                "description": "Federated Optimization with Proximal Term",
        }
}</span>

func (f *FedProxAlgorithm) UpdateHyperparameters(params map[string]interface{}) error <span class="cov0" title="0">{
        if mu, ok := params["mu"].(float64); ok </span><span class="cov0" title="0">{
                f.mu = float32(mu)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (f *FedProxAlgorithm) Aggregate(updates []ClientUpdate, globalModel []float32) ([]float32, error) <span class="cov0" title="0">{
        if len(updates) == 0 </span><span class="cov0" title="0">{
                return globalModel, fmt.Errorf("no updates to aggregate")
        }</span>

        // FedProx performs weighted aggregation with consideration for client heterogeneity
        <span class="cov0" title="0">aggregated := make([]float32, f.modelSize)
        totalWeight := float32(0)

        // Calculate weights based on number of samples and learning rates
        for _, update := range updates </span><span class="cov0" title="0">{
                // Weight based on samples and inverse of learning rate (more stable clients get higher weight)
                weight := float32(update.NumSamples)
                if update.LearningRate &gt; 0 </span><span class="cov0" title="0">{
                        // Clients with smaller learning rates (more conservative) get slightly higher weight
                        weight *= (1.0 + f.mu/update.LearningRate)
                }</span>
                <span class="cov0" title="0">totalWeight += weight

                for i, v := range update.Weights </span><span class="cov0" title="0">{
                        if i &lt; len(aggregated) </span><span class="cov0" title="0">{
                                aggregated[i] += weight * v
                        }</span>
                }
        }

        // Normalize by total weight
        <span class="cov0" title="0">if totalWeight &gt; 0 </span><span class="cov0" title="0">{
                for i := range aggregated </span><span class="cov0" title="0">{
                        aggregated[i] /= totalWeight
                }</span>
        }

        // Apply proximal term: blend with global model to ensure stability
        <span class="cov0" title="0">proximalBlend := make([]float32, f.modelSize)
        for i := 0; i &lt; f.modelSize &amp;&amp; i &lt; len(globalModel); i++ </span><span class="cov0" title="0">{
                // Proximal update: new_model = (1-α) * aggregated + α * global_model
                // where α is determined by the proximal term mu
                alpha := f.mu / (1.0 + f.mu)
                proximalBlend[i] = (1-alpha)*aggregated[i] + alpha*globalModel[i]
        }</span>

        <span class="cov0" title="0">return proximalBlend, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package aggregator

import (
        "context"
        "encoding/binary"
        "fmt"
        "log"
        "math"
        "net"
        "os"
        "sync"
        "time"

        pb "github.com/ishaileshpant/fl-go/api"
        "github.com/ishaileshpant/fl-go/pkg/federation"
        "google.golang.org/grpc"
)

// ModularAggregator implements a flexible aggregator that can use different algorithms
type ModularAggregator struct {
        pb.UnimplementedFederatedLearningServer
        plan         *federation.FLPlan
        algorithm    AggregationAlgorithm
        mu           sync.Mutex
        updates      []ClientUpdate
        modelSize    int
        currentRound int
        srv          *grpc.Server
        globalModel  []float32
        lastUpdate   time.Time
        stopChan     chan struct{}
        isAsync      bool
}

// NewModularAggregator creates a new modular aggregator with the specified algorithm
func NewModularAggregator(plan *federation.FLPlan) (*ModularAggregator, error) <span class="cov0" title="0">{
        // Determine algorithm type
        algorithmName := "fedavg" // default
        if plan.Algorithm.Name != "" </span><span class="cov0" title="0">{
                algorithmName = plan.Algorithm.Name
        }</span>

        // Create the aggregation algorithm
        <span class="cov0" title="0">algType := AlgorithmType(algorithmName)
        algorithm, err := CreateAggregationAlgorithm(algType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create aggregation algorithm: %v", err)
        }</span>

        // Determine if this is async mode
        <span class="cov0" title="0">isAsync := plan.Mode == federation.ModeAsync

        aggregator := &amp;ModularAggregator{
                plan:         plan,
                algorithm:    algorithm,
                updates:      make([]ClientUpdate, 0),
                currentRound: 0,
                isAsync:      isAsync,
                stopChan:     make(chan struct{}),
        }

        return aggregator, nil</span>
}

func (a *ModularAggregator) Start(ctx context.Context) error <span class="cov0" title="0">{
        log.Printf("Starting Modular Aggregator with %s algorithm in %s mode",
                a.algorithm.GetName(), a.plan.Mode)

        // Initialize the algorithm
        algConfig := AlgorithmConfig{
                AlgorithmName:   a.plan.Algorithm.Name,
                ModelSize:       a.modelSize,
                Hyperparameters: a.plan.Algorithm.Hyperparameters,
                Mode:            a.plan.Mode,
        }

        if err := a.algorithm.Initialize(algConfig); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize algorithm: %v", err)
        }</span>

        // Load initial model to determine model size
        <span class="cov0" title="0">if err := a.loadInitialModel(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load initial model: %v", err)
        }</span>

        // Update algorithm config with actual model size
        <span class="cov0" title="0">algConfig.ModelSize = a.modelSize
        if err := a.algorithm.Initialize(algConfig); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reinitialize algorithm with model size: %v", err)
        }</span>

        // Log algorithm hyperparameters
        <span class="cov0" title="0">hyperparams := a.algorithm.GetHyperparameters()
        log.Printf("Algorithm hyperparameters: %+v", hyperparams)

        // Start gRPC server
        lis, err := net.Listen("tcp", a.plan.Aggregator.Address)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen: %v", err)
        }</span>

        <span class="cov0" title="0">a.srv = grpc.NewServer()
        pb.RegisterFederatedLearningServer(a.srv, a)

        // Start server in background
        go func() </span><span class="cov0" title="0">{
                log.Printf("Modular aggregator server listening on %s", a.plan.Aggregator.Address)
                if err := a.srv.Serve(lis); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Server error: %v", err)
                }</span>
        }()

        // Run federation based on mode
        <span class="cov0" title="0">if a.isAsync </span><span class="cov0" title="0">{
                return a.runAsyncFederation(ctx)
        }</span> else<span class="cov0" title="0"> {
                return a.runSyncFederation(ctx)
        }</span>
}

func (a *ModularAggregator) loadInitialModel() error <span class="cov0" title="0">{
        data, err := os.ReadFile(a.plan.InitialModel)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not read initial model %s: %v", a.plan.InitialModel, err)
                // Create a dummy model for testing
                a.modelSize = 1000 // Default model size
                a.globalModel = make([]float32, a.modelSize)
                return nil
        }</span>

        // Determine model size from file
        <span class="cov0" title="0">a.modelSize = len(data) / 4 // 4 bytes per float32
        a.globalModel = make([]float32, a.modelSize)

        // Load initial weights
        for i := 0; i &lt; a.modelSize; i++ </span><span class="cov0" title="0">{
                a.globalModel[i] = math.Float32frombits(binary.LittleEndian.Uint32(data[i*4:]))
        }</span>

        <span class="cov0" title="0">log.Printf("Loaded initial model with %d parameters", a.modelSize)
        return nil</span>
}

func (a *ModularAggregator) runSyncFederation(ctx context.Context) error <span class="cov0" title="0">{
        log.Printf("Running synchronous federation with %s for %d rounds",
                a.algorithm.GetName(), a.plan.Rounds)

        // Run federated learning for specified rounds
        for round := 1; round &lt;= a.plan.Rounds; round++ </span><span class="cov0" title="0">{
                a.currentRound = round
                log.Printf("Starting round %d/%d with %s algorithm", round, a.plan.Rounds, a.algorithm.GetName())

                // Reset updates for new round
                a.mu.Lock()
                a.updates = make([]ClientUpdate, 0)
                a.mu.Unlock()

                // Wait for all collaborators to submit updates
                log.Printf("Waiting for %d collaborators to submit updates...", len(a.plan.Collaborators))
                for </span><span class="cov0" title="0">{
                        a.mu.Lock()
                        updateCount := len(a.updates)
                        a.mu.Unlock()

                        if updateCount &gt;= len(a.plan.Collaborators) </span><span class="cov0" title="0">{
                                log.Printf("Received updates from all %d collaborators", updateCount)
                                break</span>
                        }

                        <span class="cov0" title="0">log.Printf("Received %d/%d updates, waiting...", updateCount, len(a.plan.Collaborators))
                        time.Sleep(2 * time.Second)</span>
                }

                // Perform aggregation using the selected algorithm
                <span class="cov0" title="0">log.Printf("Aggregating updates for round %d using %s", round, a.algorithm.GetName())
                a.mu.Lock()
                newModel, err := a.algorithm.Aggregate(a.updates, a.globalModel)
                a.mu.Unlock()

                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("aggregation failed in round %d: %v", round, err)
                }</span>

                // Update global model
                <span class="cov0" title="0">a.globalModel = newModel

                // Save aggregated model
                if err := a.saveModel(round); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to save model in round %d: %v", round, err)
                }</span>

                <span class="cov0" title="0">log.Printf("Round %d complete using %s algorithm", round, a.algorithm.GetName())</span>
        }

        <span class="cov0" title="0">log.Printf("All %d rounds completed successfully with %s", a.plan.Rounds, a.algorithm.GetName())
        a.srv.Stop()
        return nil</span>
}

func (a *ModularAggregator) runAsyncFederation(ctx context.Context) error <span class="cov0" title="0">{
        log.Printf("Running asynchronous federation with %s algorithm", a.algorithm.GetName())

        // Start async aggregation goroutine
        go a.asyncAggregationLoop()

        // Keep server running
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                close(a.stopChan)
                a.srv.Stop()
                return ctx.Err()</span>
        }
}

func (a *ModularAggregator) asyncAggregationLoop() <span class="cov0" title="0">{
        ticker := time.NewTicker(time.Duration(a.plan.AsyncConfig.AggregationDelay) * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        a.mu.Lock()
                        updateCount := len(a.updates)
                        a.mu.Unlock()

                        if updateCount &gt;= a.plan.AsyncConfig.MinUpdates </span><span class="cov0" title="0">{
                                a.performAsyncAggregation()
                        }</span>
                case &lt;-a.stopChan:<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (a *ModularAggregator) performAsyncAggregation() <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()

        if len(a.updates) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">log.Printf("Performing async aggregation with %d updates using %s",
                len(a.updates), a.algorithm.GetName())

        // Calculate staleness for each update
        currentTime := time.Now()
        validUpdates := make([]ClientUpdate, 0)

        for _, update := range a.updates </span><span class="cov0" title="0">{
                staleness := int(currentTime.Sub(update.Timestamp).Seconds())
                update.Staleness = staleness

                if staleness &lt;= a.plan.AsyncConfig.MaxStaleness </span><span class="cov0" title="0">{
                        validUpdates = append(validUpdates, update)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Dropping stale update from %s (staleness: %d)",
                                update.CollaboratorID, staleness)
                }</span>
        }

        <span class="cov0" title="0">if len(validUpdates) == 0 </span><span class="cov0" title="0">{
                log.Printf("No valid updates to aggregate")
                return
        }</span>

        // Perform aggregation using the selected algorithm
        <span class="cov0" title="0">newModel, err := a.algorithm.Aggregate(validUpdates, a.globalModel)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Async aggregation failed: %v", err)
                return
        }</span>

        // Update global model
        <span class="cov0" title="0">a.globalModel = newModel
        a.currentRound++
        a.lastUpdate = currentTime

        // Save updated model
        if err := a.saveAsyncModel(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to save async model: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Async round %d complete using %s, model saved",
                        a.currentRound, a.algorithm.GetName())
        }</span>

        // Clear processed updates
        <span class="cov0" title="0">a.updates = make([]ClientUpdate, 0)</span>
}

func (a *ModularAggregator) saveModel(round int) error <span class="cov0" title="0">{
        buf := make([]byte, 4*a.modelSize)
        for i, v := range a.globalModel </span><span class="cov0" title="0">{
                binary.LittleEndian.PutUint32(buf[i*4:], math.Float32bits(v))
        }</span>

        <span class="cov0" title="0">outputPath := a.plan.OutputModel
        if round &lt; a.plan.Rounds </span><span class="cov0" title="0">{
                outputPath = fmt.Sprintf("save/round_%d_model.pt", round)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(outputPath, buf, 0600); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("Model saved to %s", outputPath)
        return nil</span>
}

func (a *ModularAggregator) saveAsyncModel() error <span class="cov0" title="0">{
        buf := make([]byte, 4*a.modelSize)
        for i, v := range a.globalModel </span><span class="cov0" title="0">{
                binary.LittleEndian.PutUint32(buf[i*4:], math.Float32bits(v))
        }</span>

        <span class="cov0" title="0">outputPath := fmt.Sprintf("save/async_%s_round_%d_model.pt",
                a.algorithm.GetName(), a.currentRound)
        return os.WriteFile(outputPath, buf, 0600)</span>
}

// gRPC service implementations

func (a *ModularAggregator) JoinFederation(ctx context.Context, req *pb.JoinRequest) (*pb.JoinResponse, error) <span class="cov0" title="0">{
        log.Printf("Collaborator %s joining %s federation with %s algorithm",
                req.CollaboratorId, a.plan.Mode, a.algorithm.GetName())

        // Return current global model
        buf := make([]byte, 4*a.modelSize)
        for i, v := range a.globalModel </span><span class="cov0" title="0">{
                binary.LittleEndian.PutUint32(buf[i*4:], math.Float32bits(v))
        }</span>

        <span class="cov0" title="0">return &amp;pb.JoinResponse{InitialModel: buf}, nil</span>
}

func (a *ModularAggregator) SubmitUpdate(ctx context.Context, upd *pb.ModelUpdate) (*pb.Ack, error) <span class="cov0" title="0">{
        floats := make([]float32, len(upd.ModelWeights)/4)
        for i := range floats </span><span class="cov0" title="0">{
                floats[i] = math.Float32frombits(binary.LittleEndian.Uint32(upd.ModelWeights[i*4:]))
        }</span>

        <span class="cov0" title="0">update := ClientUpdate{
                CollaboratorID: upd.CollaboratorId,
                Weights:        floats,
                Timestamp:      time.Now(),
                Round:          a.currentRound,
                NumSamples:     100,  // Default value - could be passed from client
                LearningRate:   0.01, // Default value - could be passed from client
        }

        a.mu.Lock()
        a.updates = append(a.updates, update)
        updateCount := len(a.updates)
        a.mu.Unlock()

        mode := "sync"
        if a.isAsync </span><span class="cov0" title="0">{
                mode = "async"
        }</span>

        <span class="cov0" title="0">log.Printf("Received %s update %d from %s (round %d) for %s algorithm",
                mode, updateCount, upd.CollaboratorId, a.currentRound, a.algorithm.GetName())

        return &amp;pb.Ack{Success: true}, nil</span>
}

func (a *ModularAggregator) GetLatestModel(ctx context.Context, req *pb.GetModelRequest) (*pb.GetModelResponse, error) <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()

        // Return current global model
        buf := make([]byte, 4*a.modelSize)
        for i, v := range a.globalModel </span><span class="cov0" title="0">{
                binary.LittleEndian.PutUint32(buf[i*4:], math.Float32bits(v))
        }</span>

        <span class="cov0" title="0">log.Printf("Providing latest %s model to %s (round %d)",
                a.algorithm.GetName(), req.CollaboratorId, a.currentRound)

        // Safely convert int to int32 to prevent overflow
        var currentRound int32
        if a.currentRound &gt; math.MaxInt32 </span><span class="cov0" title="0">{
                log.Printf("Warning: current round %d exceeds int32 max, capping at %d", a.currentRound, math.MaxInt32)
                currentRound = math.MaxInt32
        }</span> else<span class="cov0" title="0"> {
                currentRound = int32(a.currentRound) // #nosec G115 - Safe conversion with bounds check above
        }</span>

        <span class="cov0" title="0">return &amp;pb.GetModelResponse{
                ModelWeights: buf,
                CurrentRound: currentRound,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cli

import (
        "context"
        "fmt"
        "os"

        "github.com/ishaileshpant/fl-go/pkg/aggregator"
        "github.com/ishaileshpant/fl-go/pkg/federation"
)

// HandleAggregatorCommand handles all aggregator-related commands
func HandleAggregatorCommand(args []string) error <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("aggregator command requires a subcommand (start, stop, etc.)")
        }</span>

        <span class="cov0" title="0">subcommand := args[0]
        subArgs := args[1:]

        switch subcommand </span>{
        case "start":<span class="cov0" title="0">
                return handleAggregatorStart(subArgs)</span>
        case "--help", "-h":<span class="cov0" title="0">
                printAggregatorUsage()
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown aggregator subcommand: %s", subcommand)</span>
        }
}

func handleAggregatorStart(args []string) error <span class="cov0" title="0">{
        // Parse flags
        planPath := "plan.yaml"

        for i, arg := range args </span><span class="cov0" title="0">{
                switch arg </span>{
                case "--plan", "-p":<span class="cov0" title="0">
                        if i+1 &lt; len(args) </span><span class="cov0" title="0">{
                                planPath = args[i+1]
                        }</span>
                }
        }

        // Check if plan exists
        <span class="cov0" title="0">if _, err := os.Stat(planPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("plan file not found: %s\nRun 'fx plan init' to create a workspace first", planPath)
        }</span>

        <span class="cov0" title="0">fmt.Printf("📋 Loading federated learning plan: %s\n", planPath)
        plan, err := federation.LoadPlan(planPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load plan: %v", err)
        }</span>

        // Set default mode if not specified
        <span class="cov0" title="0">if plan.Mode == "" </span><span class="cov0" title="0">{
                plan.Mode = federation.ModeSync
        }</span>

        <span class="cov0" title="0">fmt.Printf("🚀 Starting aggregator...\n")
        fmt.Printf("📊 Configuration:\n")
        fmt.Printf("   Mode: %s\n", plan.Mode)
        fmt.Printf("   Address: %s\n", plan.Aggregator.Address)

        // Display algorithm information
        algorithmName := "fedavg" // default
        if plan.Algorithm.Name != "" </span><span class="cov0" title="0">{
                algorithmName = plan.Algorithm.Name
        }</span>
        <span class="cov0" title="0">fmt.Printf("   Algorithm: %s\n", algorithmName)

        if len(plan.Algorithm.Hyperparameters) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("   Algorithm hyperparameters:\n")
                for key, value := range plan.Algorithm.Hyperparameters </span><span class="cov0" title="0">{
                        fmt.Printf("     %s: %v\n", key, value)
                }</span>
        }

        <span class="cov0" title="0">if plan.Mode == federation.ModeSync </span><span class="cov0" title="0">{
                fmt.Printf("   Rounds: %d\n", plan.Rounds)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("   Async Config:\n")
                fmt.Printf("     Max Staleness: %d\n", plan.AsyncConfig.MaxStaleness)
                fmt.Printf("     Min Updates: %d\n", plan.AsyncConfig.MinUpdates)
                fmt.Printf("     Aggregation Delay: %ds\n", plan.AsyncConfig.AggregationDelay)
                fmt.Printf("     Staleness Weight: %.3f\n", plan.AsyncConfig.StalenessWeight)
        }</span>

        <span class="cov0" title="0">fmt.Printf("   Collaborators: %d\n", len(plan.Collaborators))
        fmt.Printf("   Initial Model: %s\n", plan.InitialModel)
        fmt.Printf("   Output Model: %s\n", plan.OutputModel)

        agg := aggregator.NewAggregator(plan)

        fmt.Printf("\n🎯 Aggregator ready! Waiting for collaborators to connect...\n")
        fmt.Printf("💡 To start collaborators, run: fx collaborator start &lt;name&gt;\n\n")

        if err := agg.Start(context.Background()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("aggregator failed: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Federated learning completed successfully!\n")
        fmt.Printf("📄 Final model saved to: %s\n", plan.OutputModel)

        return nil</span>
}

func printAggregatorUsage() <span class="cov0" title="0">{
        fmt.Println("Aggregator command - Start and manage aggregator")
        fmt.Println()
        fmt.Println("Usage:")
        fmt.Println("  fx aggregator &lt;subcommand&gt; [options]")
        fmt.Println()
        fmt.Println("Available Subcommands:")
        fmt.Println("  start     Start the aggregator")
        fmt.Println()
        fmt.Println("Options:")
        fmt.Println("  --plan, -p    Path to plan.yaml file (default: plan.yaml)")
        fmt.Println()
        fmt.Println("Examples:")
        fmt.Println("  fx aggregator start                    # Start with plan.yaml")
        fmt.Println("  fx aggregator start --plan my_plan.yaml # Start with custom plan")
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package cli

import (
        "fmt"
        "os"

        "github.com/ishaileshpant/fl-go/pkg/collaborator"
        "github.com/ishaileshpant/fl-go/pkg/federation"
)

// HandleCollaboratorCommand handles all collaborator-related commands
func HandleCollaboratorCommand(args []string) error <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("collaborator command requires a subcommand (start, etc.)")
        }</span>

        <span class="cov0" title="0">subcommand := args[0]
        subArgs := args[1:]

        switch subcommand </span>{
        case "start":<span class="cov0" title="0">
                return handleCollaboratorStart(subArgs)</span>
        case "--help", "-h":<span class="cov0" title="0">
                printCollaboratorUsage()
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown collaborator subcommand: %s", subcommand)</span>
        }
}

func handleCollaboratorStart(args []string) error <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("collaborator start requires a collaborator name")
        }</span>

        <span class="cov0" title="0">collaboratorName := args[0]

        // Parse flags
        planPath := "plan.yaml"

        for i, arg := range args[1:] </span><span class="cov0" title="0">{
                switch arg </span>{
                case "--plan", "-p":<span class="cov0" title="0">
                        if i+2 &lt; len(args) </span><span class="cov0" title="0">{
                                planPath = args[i+2]
                        }</span>
                }
        }

        // Check if plan exists
        <span class="cov0" title="0">if _, err := os.Stat(planPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("plan file not found: %s\nRun 'fx plan init' to create a workspace first", planPath)
        }</span>

        <span class="cov0" title="0">fmt.Printf("📋 Loading federated learning plan: %s\n", planPath)
        plan, err := federation.LoadPlan(planPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load plan: %v", err)
        }</span>

        // Set default mode if not specified
        <span class="cov0" title="0">if plan.Mode == "" </span><span class="cov0" title="0">{
                plan.Mode = federation.ModeSync
        }</span>

        // Find this collaborator in the plan
        <span class="cov0" title="0">var found bool
        for _, collab := range plan.Collaborators </span><span class="cov0" title="0">{
                if collab.ID == collaboratorName </span><span class="cov0" title="0">{
                        found = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  Warning: Collaborator '%s' not found in plan. Available collaborators:\n", collaboratorName)
                for _, collab := range plan.Collaborators </span><span class="cov0" title="0">{
                        fmt.Printf("   - %s\n", collab.ID)
                }</span>
                <span class="cov0" title="0">fmt.Printf("Continuing anyway...\n\n")</span>
        }

        <span class="cov0" title="0">fmt.Printf("🤝 Starting collaborator: %s\n", collaboratorName)
        fmt.Printf("📊 Configuration:\n")
        fmt.Printf("   Mode: %s\n", plan.Mode)
        fmt.Printf("   Aggregator: %s\n", plan.Aggregator.Address)

        if plan.Mode == federation.ModeSync </span><span class="cov0" title="0">{
                fmt.Printf("   Rounds: %d\n", plan.Rounds)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("   Async Config:\n")
                fmt.Printf("     Max Staleness: %d\n", plan.AsyncConfig.MaxStaleness)
                fmt.Printf("     Min Updates: %d\n", plan.AsyncConfig.MinUpdates)
                fmt.Printf("     Aggregation Delay: %ds\n", plan.AsyncConfig.AggregationDelay)
                fmt.Printf("     Staleness Weight: %.3f\n", plan.AsyncConfig.StalenessWeight)
        }</span>

        <span class="cov0" title="0">fmt.Printf("   Training Script: %s\n", plan.Tasks.Train.Script)
        fmt.Printf("   Epochs: %v\n", plan.Tasks.Train.Args["epochs"])
        fmt.Printf("   Batch Size: %v\n", plan.Tasks.Train.Args["batch_size"])

        collab := collaborator.NewCollaborator(plan, collaboratorName)

        fmt.Printf("\n🔗 Connecting to aggregator...\n")
        if err := collab.Connect(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to aggregator: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Connected successfully!\n")
        fmt.Printf("🎯 Starting federated learning...\n\n")

        // Use the new Run method that handles both sync and async modes
        if err := collab.Run(plan.Tasks.Train); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("federated learning failed: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("\n🎉 Federated learning completed!\n")
        fmt.Printf("📊 Collaborator '%s' completed training in %s mode\n", collaboratorName, plan.Mode)

        return nil</span>
}

func printCollaboratorUsage() <span class="cov0" title="0">{
        fmt.Println("Collaborator command - Start and manage collaborator")
        fmt.Println()
        fmt.Println("Usage:")
        fmt.Println("  fx collaborator &lt;subcommand&gt; [options]")
        fmt.Println()
        fmt.Println("Available Subcommands:")
        fmt.Println("  start     Start a collaborator")
        fmt.Println()
        fmt.Println("Options:")
        fmt.Println("  --plan, -p    Path to plan.yaml file (default: plan.yaml)")
        fmt.Println()
        fmt.Println("Examples:")
        fmt.Println("  fx collaborator start collaborator1           # Start collaborator1")
        fmt.Println("  fx collaborator start collab1 --plan my.yaml  # Start with custom plan")
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package cli

import (
        "fmt"
        "math"
        "os"
        "path/filepath"

        "github.com/ishaileshpant/fl-go/pkg/federation"
)

// HandlePlanCommand handles all plan-related commands
func HandlePlanCommand(args []string) error <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("plan command requires a subcommand (init, validate, etc.)")
        }</span>

        <span class="cov0" title="0">subcommand := args[0]
        subArgs := args[1:]

        switch subcommand </span>{
        case "init":<span class="cov0" title="0">
                return handlePlanInit(subArgs)</span>
        case "validate":<span class="cov0" title="0">
                return handlePlanValidate(subArgs)</span>
        case "show":<span class="cov0" title="0">
                return handlePlanShow(subArgs)</span>
        case "--help", "-h":<span class="cov0" title="0">
                printPlanUsage()
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown plan subcommand: %s", subcommand)</span>
        }
}

func handlePlanInit(args []string) error <span class="cov0" title="0">{
        // Parse flags
        planName := "fl_workspace"
        templateType := "basic"

        for i, arg := range args </span><span class="cov0" title="0">{
                switch arg </span>{
                case "--name", "-n":<span class="cov0" title="0">
                        if i+1 &lt; len(args) </span><span class="cov0" title="0">{
                                planName = args[i+1]
                        }</span>
                case "--template", "-t":<span class="cov0" title="0">
                        if i+1 &lt; len(args) </span><span class="cov0" title="0">{
                                templateType = args[i+1]
                        }</span>
                }
        }

        <span class="cov0" title="0">fmt.Printf("🔄 Initializing FL workspace: %s\n", planName)

        // Create workspace directory
        if err := os.MkdirAll(planName, 0750); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create workspace directory: %v", err)
        }</span>

        // Create subdirectories
        <span class="cov0" title="0">dirs := []string{
                "src",
                "data",
                "save",
                "logs",
                "cert",
        }

        for _, dir := range dirs </span><span class="cov0" title="0">{
                if err := os.MkdirAll(filepath.Join(planName, dir), 0750); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create directory %s: %v", dir, err)
                }</span>
        }

        // Create plan.yaml
        <span class="cov0" title="0">planPath := filepath.Join(planName, "plan.yaml")
        if err := createDefaultPlan(planPath, templateType); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create plan.yaml: %v", err)
        }</span>

        // Create Python training script
        <span class="cov0" title="0">trainScriptPath := filepath.Join(planName, "src", "taskrunner.py")
        if err := createTrainingScript(trainScriptPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create training script: %v", err)
        }</span>

        // Create initial model using Python
        <span class="cov0" title="0">fmt.Println("🔄 Creating initial model...")
        if err := createInitialModel(planName); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create initial model: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Successfully initialized FL workspace: %s\n", planName)
        fmt.Printf("📁 Workspace structure:\n")
        fmt.Printf("   %s/\n", planName)
        fmt.Printf("   ├── plan.yaml          # Federated learning configuration\n")
        fmt.Printf("   ├── src/\n")
        fmt.Printf("   │   └── taskrunner.py  # Python training script\n")
        fmt.Printf("   ├── data/              # Local datasets\n")
        fmt.Printf("   ├── save/              # Model checkpoints\n")
        fmt.Printf("   └── logs/              # Training logs\n")
        fmt.Printf("\n")
        fmt.Printf("🚀 Next steps:\n")
        fmt.Printf("   1. cd %s\n", planName)
        fmt.Printf("   2. Edit plan.yaml to configure your FL experiment\n")
        fmt.Printf("   3. Add your training data to the data/ directory\n")
        fmt.Printf("   4. Start aggregator: fx aggregator start\n")
        fmt.Printf("   5. Start collaborators: fx collaborator start &lt;name&gt;\n")

        return nil</span>
}

func createDefaultPlan(path string, templateType string) error <span class="cov0" title="0">{
        plan := &amp;federation.FLPlan{
                Rounds: 3,
                Collaborators: []federation.Collaborator{
                        {ID: "collaborator1", Address: "localhost:50052"},
                        {ID: "collaborator2", Address: "localhost:50053"},
                },
                Aggregator: federation.AggregatorEntry{
                        Address: "localhost:50051",
                },
                InitialModel: "save/init_model.pt",
                OutputModel:  "save/final_model.pt",
                Tasks: federation.TasksConfig{
                        Train: federation.TaskConfig{
                                Script: "src/taskrunner.py",
                                Args: map[string]interface{}{
                                        "epochs":     5,
                                        "batch_size": 32,
                                        "lr":         0.001,
                                        "data_path":  "data",
                                },
                        },
                },
        }

        return federation.SavePlan(plan, path)
}</span>

func createTrainingScript(path string) error <span class="cov0" title="0">{
        script := `#!/usr/bin/env python3
"""
FL-Go TaskRunner - Python training script for federated learning
This script interfaces with the Go aggregator/collaborator components.
"""
import argparse
import os
import struct
import numpy as np
import sys

def load_model(model_path):
    """Load model weights from binary file."""
    if not os.path.exists(model_path):
        # Create simple initial model
        return np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0], dtype=np.float32)
    
    with open(model_path, 'rb') as f:
        data = f.read()
    
    # Convert bytes to float32 array
    weights = []
    for i in range(0, len(data), 4):
        weight = struct.unpack('&lt;f', data[i:i+4])[0]
        weights.append(weight)
    
    return np.array(weights, dtype=np.float32)

def save_model(weights, model_path):
    """Save model weights to binary file."""
    os.makedirs(os.path.dirname(model_path), exist_ok=True)
    
    with open(model_path, 'wb') as f:
        for weight in weights:
            f.write(struct.pack('&lt;f', float(weight)))

def train_model(weights, epochs, batch_size, lr, data_path):
    """
    Simulate training process. In a real implementation, this would:
    1. Load local training data from data_path
    2. Train the model for specified epochs
    3. Return updated weights
    """
    print(f"🔄 Training model for {epochs} epochs (batch_size={batch_size}, lr={lr})")
    print(f"📂 Data path: {data_path}")
    print(f"📊 Model size: {len(weights)} parameters")
    
    # Simulate training by adding small random updates
    np.random.seed(42)  # Reproducible for demo
    gradients = np.random.normal(0, 0.01, len(weights))
    updated_weights = weights + lr * gradients
    
    print(f"✅ Training completed")
    return updated_weights

def main():
    parser = argparse.ArgumentParser(description='FL-Go TaskRunner')
    parser.add_argument('--model-in', required=True, help='Input model path')
    parser.add_argument('--model-out', required=True, help='Output model path')
    parser.add_argument('--epochs', type=int, default=5, help='Number of training epochs')
    parser.add_argument('--batch-size', type=int, default=32, help='Batch size')
    parser.add_argument('--lr', type=float, default=0.001, help='Learning rate')
    parser.add_argument('--data-path', default='data', help='Path to training data')
    
    args = parser.parse_args()
    
    try:
        # Load model
        print(f"📖 Loading model from: {args.model_in}")
        weights = load_model(args.model_in)
        
        # Train model
        updated_weights = train_model(
            weights, 
            args.epochs, 
            args.batch_size, 
            args.lr, 
            args.data_path
        )
        
        # Save updated model
        print(f"💾 Saving model to: {args.model_out}")
        save_model(updated_weights, args.model_out)
        
        print(f"🎯 Training completed successfully")
        
    except Exception as e:
        print(f"❌ Training failed: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
`
        return os.WriteFile(path, []byte(script), 0600) // Changed from 0700 to meet security requirements
}</span>

func createInitialModel(workspacePath string) error <span class="cov0" title="0">{
        modelPath := filepath.Join(workspacePath, "save", "init_model.pt")

        // Create save directory
        if err := os.MkdirAll(filepath.Dir(modelPath), 0750); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create a larger initial model with 1000 float32 parameters
        // This mimics a more realistic neural network model
        <span class="cov0" title="0">weights := make([]float32, 1000)
        for i := range weights </span><span class="cov0" title="0">{
                weights[i] = float32(i) * 0.001 // Small initial weights
        }</span>

        // Convert to binary format (little-endian float32)
        <span class="cov0" title="0">buf := make([]byte, len(weights)*4)
        for i, weight := range weights </span><span class="cov0" title="0">{
                bits := math.Float32bits(weight)
                buf[i*4] = byte(bits)
                buf[i*4+1] = byte(bits &gt;&gt; 8)
                buf[i*4+2] = byte(bits &gt;&gt; 16)
                buf[i*4+3] = byte(bits &gt;&gt; 24)
        }</span>

        <span class="cov0" title="0">return os.WriteFile(modelPath, buf, 0600)</span>
}

func handlePlanValidate(args []string) error <span class="cov0" title="0">{
        planPath := "plan.yaml"
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                planPath = args[0]
        }</span>

        <span class="cov0" title="0">plan, err := federation.LoadPlan(planPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load plan: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Plan validation successful\n")
        fmt.Printf("📋 Configuration:\n")
        fmt.Printf("   Rounds: %d\n", plan.Rounds)
        fmt.Printf("   Collaborators: %d\n", len(plan.Collaborators))
        fmt.Printf("   Aggregator: %s\n", plan.Aggregator.Address)
        fmt.Printf("   Initial Model: %s\n", plan.InitialModel)
        fmt.Printf("   Output Model: %s\n", plan.OutputModel)

        return nil</span>
}

func handlePlanShow(args []string) error <span class="cov0" title="0">{
        planPath := "plan.yaml"
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                planPath = args[0]
        }</span>

        <span class="cov0" title="0">content, err := os.ReadFile(planPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read plan: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Print(string(content))
        return nil</span>
}

func printPlanUsage() <span class="cov0" title="0">{
        fmt.Println("Plan command - Manage federated learning plans")
        fmt.Println()
        fmt.Println("Usage:")
        fmt.Println("  fx plan &lt;subcommand&gt; [options]")
        fmt.Println()
        fmt.Println("Available Subcommands:")
        fmt.Println("  init      Initialize a new FL workspace")
        fmt.Println("  validate  Validate an existing plan")
        fmt.Println("  show      Display plan contents")
        fmt.Println()
        fmt.Println("Examples:")
        fmt.Println("  fx plan init --name my_experiment    # Create workspace 'my_experiment'")
        fmt.Println("  fx plan validate plan.yaml           # Validate plan.yaml")
        fmt.Println("  fx plan show                          # Show current plan")
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package collaborator

import (
        "context"
        "fmt"
        "log"
        "os"
        "os/exec"
        "regexp"
        "strings"
        "time"

        pb "github.com/ishaileshpant/fl-go/api"
        "github.com/ishaileshpant/fl-go/pkg/federation"
        "github.com/ishaileshpant/fl-go/pkg/security"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

type SimpleCollaborator struct {
        plan *federation.FLPlan
        id   string
        cli  pb.FederatedLearningClient
}

func NewCollaborator(plan *federation.FLPlan, id string) *SimpleCollaborator <span class="cov0" title="0">{
        return &amp;SimpleCollaborator{plan: plan, id: id}
}</span>

func (c *SimpleCollaborator) Connect() error <span class="cov0" title="0">{
        log.Printf("Connecting to aggregator at %s", c.plan.Aggregator.Address)

        // Initialize TLS manager for secure communication
        tlsManager, err := security.NewTLSManager(security.TLSConfig(c.plan.Security.TLS), "certs")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize TLS manager: %w", err)
        }</span>

        // Get client dial options with TLS support
        <span class="cov0" title="0">dialOpts, err := tlsManager.NewClientDialOptions()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get client dial options: %w", err)
        }</span>

        // Fallback to insecure credentials if TLS is not enabled
        <span class="cov0" title="0">if len(dialOpts) == 0 </span><span class="cov0" title="0">{
                dialOpts = []grpc.DialOption{grpc.WithTransportCredentials(insecure.NewCredentials())}
        }</span>

        <span class="cov0" title="0">conn, err := grpc.NewClient(c.plan.Aggregator.Address, dialOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">c.cli = pb.NewFederatedLearningClient(conn)
        resp, err := c.cli.JoinFederation(context.Background(), &amp;pb.JoinRequest{CollaboratorId: c.id})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create models directory if it doesn't exist
        <span class="cov0" title="0">if err := os.MkdirAll("models", 0750); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile("models/model_init.pt", resp.InitialModel, 0600)</span>
}

func (c *SimpleCollaborator) RunTrainTask(task federation.TaskConfig) ([]byte, error) <span class="cov0" title="0">{
        args := []string{task.Script, "--model-in", "models/model_init.pt", "--model-out", "models/update.pt"}
        for k, v := range task.Args </span><span class="cov0" title="0">{
                // Validate key and value to prevent injection
                if !isValidArgument(k) || !isValidArgument(fmt.Sprint(v)) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid argument detected: key=%s, value=%v", k, v)
                }</span>

                // Convert snake_case to kebab-case for Python argparse
                <span class="cov0" title="0">kebabKey := strings.ReplaceAll(k, "_", "-")
                args = append(args, fmt.Sprintf("--%s", kebabKey), fmt.Sprint(v))</span>
        }

        <span class="cov0" title="0">log.Printf("Running training task: python3 %v", args)
        cmd := exec.Command("python3", args...) // #nosec G204 - Arguments validated with whitelist above
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return os.ReadFile("models/update.pt")</span>
}

func (c *SimpleCollaborator) SubmitUpdate(weights []byte) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()
        _, err := c.cli.SubmitUpdate(ctx, &amp;pb.ModelUpdate{CollaboratorId: c.id, ModelWeights: weights})
        return err
}</span>

func (c *SimpleCollaborator) GetLatestModel() ([]byte, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()
        resp, err := c.cli.GetLatestModel(ctx, &amp;pb.GetModelRequest{CollaboratorId: c.id})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp.ModelWeights, nil</span>
}

// RunSyncMode runs the traditional synchronous FL mode
func (c *SimpleCollaborator) RunSyncMode(task federation.TaskConfig) error <span class="cov0" title="0">{
        log.Printf("Starting SYNC mode training for %d rounds", c.plan.Rounds)

        for round := 1; round &lt;= c.plan.Rounds; round++ </span><span class="cov0" title="0">{
                log.Printf("Starting round %d/%d", round, c.plan.Rounds)

                // Train on current model
                weights, err := c.RunTrainTask(task)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("training failed in round %d: %v", round, err)
                }</span>

                // Submit update
                <span class="cov0" title="0">if err := c.SubmitUpdate(weights); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to submit update in round %d: %v", round, err)
                }</span>

                <span class="cov0" title="0">log.Printf("Round %d/%d completed", round, c.plan.Rounds)

                // Wait for next round (in sync mode, we wait for all collaborators)
                if round &lt; c.plan.Rounds </span><span class="cov0" title="0">{
                        log.Printf("Waiting for next round...")
                        time.Sleep(5 * time.Second)
                }</span>
        }

        <span class="cov0" title="0">log.Printf("SYNC mode training completed")
        return nil</span>
}

// RunAsyncMode runs the asynchronous FL mode based on Papaya paper
func (c *SimpleCollaborator) RunAsyncMode(task federation.TaskConfig) error <span class="cov0" title="0">{
        log.Printf("Starting ASYNC mode training (continuous)")

        round := 1
        for </span><span class="cov0" title="0">{
                log.Printf("Starting async round %d", round)

                // Train on current model
                weights, err := c.RunTrainTask(task)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("training failed in async round %d: %v", round, err)
                }</span>

                // Submit update immediately
                <span class="cov0" title="0">if err := c.SubmitUpdate(weights); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to submit update in async round %d: %v", round, err)
                }</span>

                <span class="cov0" title="0">log.Printf("Async round %d completed", round)

                // In async mode, get the latest model from aggregator after each round
                log.Printf("Getting latest model from aggregator...")
                latestModel, err := c.GetLatestModel()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to get latest model: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        // Update the local model with the latest from aggregator
                        if err := os.WriteFile("models/model_init.pt", latestModel, 0600); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: failed to save latest model: %v", err)
                        }</span> else<span class="cov0" title="0"> {
                                log.Printf("Updated local model with latest from aggregator")
                        }</span>
                }

                // In async mode, we can continue immediately without waiting
                // But we add a small delay to prevent overwhelming the system
                <span class="cov0" title="0">time.Sleep(2 * time.Second)

                round++

                // Optional: add a maximum round limit for async mode
                if c.plan.Rounds &gt; 0 &amp;&amp; round &gt; c.plan.Rounds </span><span class="cov0" title="0">{
                        log.Printf("Reached maximum rounds (%d), stopping async training", c.plan.Rounds)
                        break</span>
                }
        }

        <span class="cov0" title="0">log.Printf("ASYNC mode training completed")
        return nil</span>
}

// Run starts the collaborator in the appropriate mode
func (c *SimpleCollaborator) Run(task federation.TaskConfig) error <span class="cov0" title="0">{
        // Set default mode if not specified
        if c.plan.Mode == "" </span><span class="cov0" title="0">{
                c.plan.Mode = federation.ModeSync
        }</span>

        <span class="cov0" title="0">switch c.plan.Mode </span>{
        case federation.ModeAsync:<span class="cov0" title="0">
                return c.RunAsyncMode(task)</span>
        default:<span class="cov0" title="0">
                return c.RunSyncMode(task)</span>
        }
}

// isValidArgument validates command line arguments to prevent injection attacks
func isValidArgument(arg string) bool <span class="cov0" title="0">{
        // Allow alphanumeric characters, dots, slashes, dashes, underscores, and equals
        // This is a whitelist approach for security
        validPattern := regexp.MustCompile(`^[a-zA-Z0-9._/\-=]+$`)
        return validPattern.MatchString(arg) &amp;&amp; len(arg) &lt; 256 // Also limit length
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package federation

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "gopkg.in/yaml.v3"
)

// LoadPlan loads a federated learning plan from a YAML file.
func LoadPlan(path string) (*FLPlan, error) <span class="cov0" title="0">{
        // Validate and sanitize the file path to prevent path traversal
        if err := validateFilePath(path); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">data, err := os.ReadFile(path) // #nosec G304 - Path validated with whitelist above
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var plan FLPlan
        if err := yaml.Unmarshal(data, &amp;plan); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;plan, nil</span>
}

// SavePlan saves a federated learning plan to a YAML file.
func SavePlan(plan *FLPlan, path string) error <span class="cov0" title="0">{
        data, err := yaml.Marshal(plan)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0600)</span>
}

// validateFilePath validates and sanitizes file paths to prevent directory traversal attacks
func validateFilePath(path string) error <span class="cov0" title="0">{
        // Clean the path to resolve any "../" sequences
        cleanPath := filepath.Clean(path)

        // Check for path traversal attempts
        if strings.Contains(cleanPath, "..") </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid file path: path traversal detected")
        }</span>

        // Only allow specific file extensions
        <span class="cov0" title="0">ext := filepath.Ext(cleanPath)
        if ext != ".yaml" &amp;&amp; ext != ".yml" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid file extension: only .yaml and .yml files are allowed")
        }</span>

        // Check path length
        <span class="cov0" title="0">if len(cleanPath) &gt; 256 </span><span class="cov0" title="0">{
                return fmt.Errorf("file path too long: maximum 256 characters allowed")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package monitoring

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/gorilla/mux"
        "github.com/gorilla/websocket"
        "github.com/rs/cors"
)

// APIServer handles HTTP requests for the monitoring system
type APIServer struct {
        service  MonitoringService
        config   *MonitoringConfig
        router   *mux.Router
        upgrader websocket.Upgrader
}

// NewAPIServer creates a new API server instance
func NewAPIServer(service MonitoringService, config *MonitoringConfig) *APIServer <span class="cov0" title="0">{
        server := &amp;APIServer{
                service: service,
                config:  config,
                router:  mux.NewRouter(),
                upgrader: websocket.Upgrader{
                        CheckOrigin: func(r *http.Request) bool </span><span class="cov0" title="0">{
                                return true // Allow all origins in development
                        }</span>,
                        ReadBufferSize:  1024,
                        WriteBufferSize: 1024,
                },
        }

        <span class="cov0" title="0">server.setupRoutes()
        return server</span>
}

// Start starts the API server
func (s *APIServer) Start() error <span class="cov0" title="0">{
        // Setup CORS
        c := cors.New(cors.Options{
                AllowedOrigins: []string{"*"}, // Configure appropriately for production
                AllowedMethods: []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
                AllowedHeaders: []string{"*"},
        })

        handler := c.Handler(s.router)

        addr := fmt.Sprintf(":%d", s.config.APIPort)
        log.Printf("Starting monitoring API server on %s", addr)

        return http.ListenAndServe(addr, handler)
}</span>

// setupRoutes configures all API routes
func (s *APIServer) setupRoutes() <span class="cov0" title="0">{
        api := s.router.PathPrefix("/api/v1").Subrouter()

        // Health check
        api.HandleFunc("/health", s.handleHealth).Methods("GET")
        api.HandleFunc("/stats", s.handleStats).Methods("GET")

        // Federation endpoints
        federations := api.PathPrefix("/federations").Subrouter()
        federations.HandleFunc("", s.handleListFederations).Methods("GET")
        federations.HandleFunc("", s.handleCreateFederation).Methods("POST")
        federations.HandleFunc("/{id}", s.handleGetFederation).Methods("GET")
        federations.HandleFunc("/{id}", s.handleUpdateFederation).Methods("PUT")
        federations.HandleFunc("/{id}/overview", s.handleGetSystemOverview).Methods("GET")
        federations.HandleFunc("/{id}/insights", s.handleGetPerformanceInsights).Methods("GET")
        federations.HandleFunc("/{id}/convergence", s.handleGetConvergenceAnalysis).Methods("GET")
        federations.HandleFunc("/{id}/efficiency", s.handleGetEfficiencyMetrics).Methods("GET")

        // Collaborator endpoints
        collaborators := api.PathPrefix("/collaborators").Subrouter()
        collaborators.HandleFunc("", s.handleListCollaborators).Methods("GET")
        collaborators.HandleFunc("", s.handleCreateCollaborator).Methods("POST")
        collaborators.HandleFunc("/{id}", s.handleGetCollaborator).Methods("GET")
        collaborators.HandleFunc("/{id}", s.handleUpdateCollaborator).Methods("PUT")

        // Round endpoints
        rounds := api.PathPrefix("/rounds").Subrouter()
        rounds.HandleFunc("", s.handleListRounds).Methods("GET")
        rounds.HandleFunc("", s.handleCreateRound).Methods("POST")
        rounds.HandleFunc("/{id}", s.handleGetRound).Methods("GET")
        rounds.HandleFunc("/{id}", s.handleUpdateRound).Methods("PUT")

        // Model update endpoints
        updates := api.PathPrefix("/updates").Subrouter()
        updates.HandleFunc("", s.handleListModelUpdates).Methods("GET")
        updates.HandleFunc("", s.handleCreateModelUpdate).Methods("POST")
        updates.HandleFunc("/statistics", s.handleGetUpdateStatistics).Methods("GET")

        // Aggregation endpoints
        aggregations := api.PathPrefix("/aggregations").Subrouter()
        aggregations.HandleFunc("", s.handleListAggregations).Methods("GET")
        aggregations.HandleFunc("", s.handleCreateAggregation).Methods("POST")
        aggregations.HandleFunc("/statistics", s.handleGetAggregationStatistics).Methods("GET")

        // Resource metrics endpoints
        resources := api.PathPrefix("/resources").Subrouter()
        resources.HandleFunc("/{source}", s.handleGetResourceMetrics).Methods("GET")
        resources.HandleFunc("/{source}", s.handleCreateResourceMetrics).Methods("POST")

        // Event endpoints
        events := api.PathPrefix("/events").Subrouter()
        events.HandleFunc("", s.handleListEvents).Methods("GET")
        events.HandleFunc("", s.handleCreateEvent).Methods("POST")
        events.HandleFunc("/alerts", s.handleGetActiveAlerts).Methods("GET")

        // Dashboard endpoints
        dashboards := api.PathPrefix("/dashboards").Subrouter()
        dashboards.HandleFunc("", s.handleListDashboards).Methods("GET")
        dashboards.HandleFunc("", s.handleCreateDashboard).Methods("POST")
        dashboards.HandleFunc("/{id}", s.handleGetDashboard).Methods("GET")
        dashboards.HandleFunc("/{id}", s.handleUpdateDashboard).Methods("PUT")
        dashboards.HandleFunc("/{id}", s.handleDeleteDashboard).Methods("DELETE")

        // WebSocket endpoint for real-time events
        api.HandleFunc("/ws", s.handleWebSocket).Methods("GET")

        // Serve static files for the web UI
        s.router.PathPrefix("/").Handler(http.FileServer(http.Dir("./web/dist/")))
}</span>

// Health check endpoint
func (s *APIServer) handleHealth(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        if err := s.service.HealthCheck(ctx); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusServiceUnavailable, "Service unhealthy", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, map[string]interface{}{
                "status":    "healthy",
                "timestamp": time.Now(),
                "version":   "1.0.0",
        })</span>
}

// Stats endpoint
func (s *APIServer) handleStats(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        stats, err := s.service.GetMetricsStats(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to get stats", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, stats)</span>
}

// Federation handlers
func (s *APIServer) handleListFederations(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        filter := s.parseMetricsFilter(r)

        if r.URL.Query().Get("active") == "true" </span><span class="cov0" title="0">{
                federations, err := s.service.GetActiveFederations(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        s.sendError(w, http.StatusInternalServerError, "Failed to get active federations", err)
                        return
                }</span>
                <span class="cov0" title="0">s.sendSuccess(w, federations)
                return</span>
        }

        <span class="cov0" title="0">federations, err := s.service.GetFederationHistory(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to get federation history", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, federations)</span>
}

func (s *APIServer) handleCreateFederation(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        var federation FederationMetrics
        if err := json.NewDecoder(r.Body).Decode(&amp;federation); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusBadRequest, "Invalid request body", err)
                return
        }</span>

        <span class="cov0" title="0">if err := s.service.RegisterFederation(ctx, &amp;federation); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to register federation", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, federation)</span>
}

func (s *APIServer) handleGetFederation(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        id := mux.Vars(r)["id"]

        federation, err := s.service.GetFederation(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusNotFound, "Federation not found", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, federation)</span>
}

func (s *APIServer) handleUpdateFederation(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        id := mux.Vars(r)["id"]

        var federation FederationMetrics
        if err := json.NewDecoder(r.Body).Decode(&amp;federation); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusBadRequest, "Invalid request body", err)
                return
        }</span>

        <span class="cov0" title="0">if err := s.service.UpdateFederation(ctx, id, &amp;federation); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to update federation", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, federation)</span>
}

func (s *APIServer) handleGetSystemOverview(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        id := mux.Vars(r)["id"]

        overview, err := s.service.GetSystemOverview(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to get system overview", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, overview)</span>
}

func (s *APIServer) handleGetPerformanceInsights(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        id := mux.Vars(r)["id"]

        insights, err := s.service.GetPerformanceInsights(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to get performance insights", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, insights)</span>
}

func (s *APIServer) handleGetConvergenceAnalysis(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        id := mux.Vars(r)["id"]

        analysis, err := s.service.GetConvergenceAnalysis(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to get convergence analysis", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, analysis)</span>
}

func (s *APIServer) handleGetEfficiencyMetrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        id := mux.Vars(r)["id"]

        metrics, err := s.service.GetEfficiencyMetrics(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to get efficiency metrics", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, metrics)</span>
}

// Collaborator handlers
func (s *APIServer) handleListCollaborators(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        filter := s.parseMetricsFilter(r)

        // Check if filtering by federation
        if federationID := r.URL.Query().Get("federation_id"); federationID != "" </span><span class="cov0" title="0">{
                collaborators, err := s.service.GetFederationCollaborators(ctx, federationID)
                if err != nil </span><span class="cov0" title="0">{
                        s.sendError(w, http.StatusInternalServerError, "Failed to get federation collaborators", err)
                        return
                }</span>
                <span class="cov0" title="0">s.sendSuccess(w, collaborators)
                return</span>
        }

        <span class="cov0" title="0">collaborators, err := s.service.GetCollaboratorHistory(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to get collaborator history", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, collaborators)</span>
}

func (s *APIServer) handleCreateCollaborator(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        var collaborator CollaboratorMetrics
        if err := json.NewDecoder(r.Body).Decode(&amp;collaborator); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusBadRequest, "Invalid request body", err)
                return
        }</span>

        <span class="cov0" title="0">if err := s.service.RegisterCollaborator(ctx, &amp;collaborator); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to register collaborator", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, collaborator)</span>
}

func (s *APIServer) handleGetCollaborator(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        id := mux.Vars(r)["id"]

        collaborator, err := s.service.GetCollaborator(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusNotFound, "Collaborator not found", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, collaborator)</span>
}

func (s *APIServer) handleUpdateCollaborator(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        id := mux.Vars(r)["id"]

        var collaborator CollaboratorMetrics
        if err := json.NewDecoder(r.Body).Decode(&amp;collaborator); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusBadRequest, "Invalid request body", err)
                return
        }</span>

        <span class="cov0" title="0">if err := s.service.UpdateCollaborator(ctx, id, &amp;collaborator); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to update collaborator", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, collaborator)</span>
}

// Round handlers
func (s *APIServer) handleListRounds(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        filter := s.parseMetricsFilter(r)

        // Check if filtering by federation
        if federationID := r.URL.Query().Get("federation_id"); federationID != "" </span><span class="cov0" title="0">{
                rounds, err := s.service.GetFederationRounds(ctx, federationID)
                if err != nil </span><span class="cov0" title="0">{
                        s.sendError(w, http.StatusInternalServerError, "Failed to get federation rounds", err)
                        return
                }</span>
                <span class="cov0" title="0">s.sendSuccess(w, rounds)
                return</span>
        }

        <span class="cov0" title="0">rounds, err := s.service.GetRoundHistory(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to get round history", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, rounds)</span>
}

func (s *APIServer) handleCreateRound(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        var round RoundMetrics
        if err := json.NewDecoder(r.Body).Decode(&amp;round); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusBadRequest, "Invalid request body", err)
                return
        }</span>

        <span class="cov0" title="0">if err := s.service.RecordRoundStart(ctx, &amp;round); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to record round start", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, round)</span>
}

func (s *APIServer) handleGetRound(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        id := mux.Vars(r)["id"]

        round, err := s.service.GetRound(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusNotFound, "Round not found", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, round)</span>
}

func (s *APIServer) handleUpdateRound(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        id := mux.Vars(r)["id"]

        var round RoundMetrics
        if err := json.NewDecoder(r.Body).Decode(&amp;round); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusBadRequest, "Invalid request body", err)
                return
        }</span>

        <span class="cov0" title="0">if err := s.service.RecordRoundEnd(ctx, id, &amp;round); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to record round end", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, round)</span>
}

// Model update handlers
func (s *APIServer) handleListModelUpdates(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        filter := s.parseMetricsFilter(r)

        updates, err := s.service.GetModelUpdates(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to get model updates", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, updates)</span>
}

func (s *APIServer) handleCreateModelUpdate(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        var update ModelUpdateMetrics
        if err := json.NewDecoder(r.Body).Decode(&amp;update); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusBadRequest, "Invalid request body", err)
                return
        }</span>

        <span class="cov0" title="0">if err := s.service.RecordModelUpdate(ctx, &amp;update); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to record model update", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, update)</span>
}

func (s *APIServer) handleGetUpdateStatistics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        federationID := r.URL.Query().Get("federation_id")
        roundNumberStr := r.URL.Query().Get("round_number")

        if federationID == "" || roundNumberStr == "" </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusBadRequest, "federation_id and round_number are required", nil)
                return
        }</span>

        <span class="cov0" title="0">roundNumber, err := strconv.Atoi(roundNumberStr)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusBadRequest, "Invalid round_number", err)
                return
        }</span>

        <span class="cov0" title="0">stats, err := s.service.GetUpdateStatistics(ctx, federationID, roundNumber)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to get update statistics", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, stats)</span>
}

// Aggregation handlers
func (s *APIServer) handleListAggregations(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        filter := s.parseMetricsFilter(r)

        aggregations, err := s.service.GetAggregations(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to get aggregations", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, aggregations)</span>
}

func (s *APIServer) handleCreateAggregation(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        var aggregation AggregationMetrics
        if err := json.NewDecoder(r.Body).Decode(&amp;aggregation); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusBadRequest, "Invalid request body", err)
                return
        }</span>

        <span class="cov0" title="0">if err := s.service.RecordAggregation(ctx, &amp;aggregation); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to record aggregation", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, aggregation)</span>
}

func (s *APIServer) handleGetAggregationStatistics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        federationID := r.URL.Query().Get("federation_id")
        if federationID == "" </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusBadRequest, "federation_id is required", nil)
                return
        }</span>

        <span class="cov0" title="0">stats, err := s.service.GetAggregationStatistics(ctx, federationID)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to get aggregation statistics", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, stats)</span>
}

// Resource metrics handlers
func (s *APIServer) handleGetResourceMetrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        source := mux.Vars(r)["source"]

        // Parse time range (default to last hour)
        timeRangeStr := r.URL.Query().Get("time_range")
        timeRange := time.Hour
        if timeRangeStr != "" </span><span class="cov0" title="0">{
                if parsed, err := time.ParseDuration(timeRangeStr); err == nil </span><span class="cov0" title="0">{
                        timeRange = parsed
                }</span>
        }

        <span class="cov0" title="0">metrics, err := s.service.GetResourceMetrics(ctx, source, timeRange)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to get resource metrics", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, metrics)</span>
}

func (s *APIServer) handleCreateResourceMetrics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        source := mux.Vars(r)["source"]

        var metrics ResourceMetrics
        if err := json.NewDecoder(r.Body).Decode(&amp;metrics); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusBadRequest, "Invalid request body", err)
                return
        }</span>

        <span class="cov0" title="0">if err := s.service.RecordResourceMetrics(ctx, source, &amp;metrics); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to record resource metrics", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, metrics)</span>
}

// Event handlers
func (s *APIServer) handleListEvents(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        filter := s.parseMetricsFilter(r)

        events, err := s.service.GetEvents(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to get events", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, events)</span>
}

func (s *APIServer) handleCreateEvent(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        var event MonitoringEvent
        if err := json.NewDecoder(r.Body).Decode(&amp;event); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusBadRequest, "Invalid request body", err)
                return
        }</span>

        <span class="cov0" title="0">if err := s.service.RecordEvent(ctx, &amp;event); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to record event", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, event)</span>
}

func (s *APIServer) handleGetActiveAlerts(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        federationID := r.URL.Query().Get("federation_id")
        if federationID == "" </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusBadRequest, "federation_id is required", nil)
                return
        }</span>

        <span class="cov0" title="0">alerts, err := s.service.GetActiveAlerts(ctx, federationID)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to get active alerts", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, alerts)</span>
}

// Dashboard handlers
func (s *APIServer) handleListDashboards(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        dashboards, err := s.service.ListDashboards(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to get dashboards", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, dashboards)</span>
}

func (s *APIServer) handleCreateDashboard(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        var dashboard Dashboard
        if err := json.NewDecoder(r.Body).Decode(&amp;dashboard); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusBadRequest, "Invalid request body", err)
                return
        }</span>

        <span class="cov0" title="0">if err := s.service.CreateDashboard(ctx, &amp;dashboard); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to create dashboard", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, dashboard)</span>
}

func (s *APIServer) handleGetDashboard(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        id := mux.Vars(r)["id"]

        dashboard, err := s.service.GetDashboard(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusNotFound, "Dashboard not found", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, dashboard)</span>
}

func (s *APIServer) handleUpdateDashboard(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        id := mux.Vars(r)["id"]

        var dashboard Dashboard
        if err := json.NewDecoder(r.Body).Decode(&amp;dashboard); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusBadRequest, "Invalid request body", err)
                return
        }</span>

        <span class="cov0" title="0">if err := s.service.UpdateDashboard(ctx, id, &amp;dashboard); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to update dashboard", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, dashboard)</span>
}

func (s *APIServer) handleDeleteDashboard(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        id := mux.Vars(r)["id"]

        if err := s.service.DeleteDashboard(ctx, id); err != nil </span><span class="cov0" title="0">{
                s.sendError(w, http.StatusInternalServerError, "Failed to delete dashboard", err)
                return
        }</span>

        <span class="cov0" title="0">s.sendSuccess(w, map[string]string{"message": "Dashboard deleted successfully"})</span>
}

// WebSocket handler for real-time events
func (s *APIServer) handleWebSocket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        conn, err := s.upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("WebSocket upgrade failed: %v", err)
                return
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Parse query parameters
        federationID := r.URL.Query().Get("federation_id")
        eventTypesStr := r.URL.Query().Get("event_types")

        var eventTypes []MetricType
        if eventTypesStr != "" </span><span class="cov0" title="0">{
                for _, typeStr := range strings.Split(eventTypesStr, ",") </span><span class="cov0" title="0">{
                        eventTypes = append(eventTypes, MetricType(strings.TrimSpace(typeStr)))
                }</span>
        }

        // Subscribe to events
        <span class="cov0" title="0">ctx := context.Background()
        eventChan, err := s.service.SubscribeToEvents(ctx, federationID, eventTypes)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to subscribe to events: %v", err)
                return
        }</span>

        // Handle WebSocket communication
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        // Read message from client (for keepalive or unsubscribe)
                        _, _, err := conn.ReadMessage()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("WebSocket read error: %v", err)
                                return
                        }</span>
                }
        }()

        // Send events to client
        <span class="cov0" title="0">for event := range eventChan </span><span class="cov0" title="0">{
                if err := conn.WriteJSON(event); err != nil </span><span class="cov0" title="0">{
                        log.Printf("WebSocket write error: %v", err)
                        break</span>
                }
        }
}

// Helper methods
func (s *APIServer) parseMetricsFilter(r *http.Request) *MetricsFilter <span class="cov0" title="0">{
        filter := &amp;MetricsFilter{}

        if federationID := r.URL.Query().Get("federation_id"); federationID != "" </span><span class="cov0" title="0">{
                filter.FederationID = federationID
        }</span>

        <span class="cov0" title="0">if collaboratorID := r.URL.Query().Get("collaborator_id"); collaboratorID != "" </span><span class="cov0" title="0">{
                filter.CollaboratorID = collaboratorID
        }</span>

        <span class="cov0" title="0">if status := r.URL.Query().Get("status"); status != "" </span><span class="cov0" title="0">{
                filter.Status = status
        }</span>

        <span class="cov0" title="0">if metricType := r.URL.Query().Get("metric_type"); metricType != "" </span><span class="cov0" title="0">{
                filter.MetricType = MetricType(metricType)
        }</span>

        <span class="cov0" title="0">if roundNumberStr := r.URL.Query().Get("round_number"); roundNumberStr != "" </span><span class="cov0" title="0">{
                if roundNumber, err := strconv.Atoi(roundNumberStr); err == nil </span><span class="cov0" title="0">{
                        filter.RoundNumber = &amp;roundNumber
                }</span>
        }

        <span class="cov0" title="0">if pageStr := r.URL.Query().Get("page"); pageStr != "" </span><span class="cov0" title="0">{
                if page, err := strconv.Atoi(pageStr); err == nil </span><span class="cov0" title="0">{
                        filter.Page = page
                }</span>
        }

        <span class="cov0" title="0">if perPageStr := r.URL.Query().Get("per_page"); perPageStr != "" </span><span class="cov0" title="0">{
                if perPage, err := strconv.Atoi(perPageStr); err == nil </span><span class="cov0" title="0">{
                        filter.PerPage = perPage
                }</span>
        }

        <span class="cov0" title="0">if startTimeStr := r.URL.Query().Get("start_time"); startTimeStr != "" </span><span class="cov0" title="0">{
                if startTime, err := time.Parse(time.RFC3339, startTimeStr); err == nil </span><span class="cov0" title="0">{
                        filter.StartTime = &amp;startTime
                }</span>
        }

        <span class="cov0" title="0">if endTimeStr := r.URL.Query().Get("end_time"); endTimeStr != "" </span><span class="cov0" title="0">{
                if endTime, err := time.Parse(time.RFC3339, endTimeStr); err == nil </span><span class="cov0" title="0">{
                        filter.EndTime = &amp;endTime
                }</span>
        }

        <span class="cov0" title="0">return filter</span>
}

func (s *APIServer) sendSuccess(w http.ResponseWriter, data interface{}) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        response := APIResponse{
                Success: true,
                Data:    data,
        }

        json.NewEncoder(w).Encode(response)
}</span>

func (s *APIServer) sendError(w http.ResponseWriter, statusCode int, message string, err error) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)

        errorMsg := message
        if err != nil </span><span class="cov0" title="0">{
                errorMsg = fmt.Sprintf("%s: %v", message, err)
        }</span>

        <span class="cov0" title="0">response := APIResponse{
                Success: false,
                Error:   errorMsg,
        }

        json.NewEncoder(w).Encode(response)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package monitoring

import (
        "context"
        "crypto/rand"
        "crypto/subtle"
        "encoding/base64"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

// AuthConfig represents authentication configuration
type AuthConfig struct {
        Enabled      bool         `yaml:"enabled"`
        APIKeyAuth   APIKeyConfig `yaml:"api_key"`
        JWTAuth      JWTConfig    `yaml:"jwt"`
        OAuthConfig  OAuthConfig  `yaml:"oauth"`
        RequiredRole string       `yaml:"required_role"` // admin, monitor, readonly
}

// APIKeyConfig represents API key authentication configuration
type APIKeyConfig struct {
        Enabled    bool              `yaml:"enabled"`
        Keys       map[string]string `yaml:"keys"`        // key -&gt; role mapping
        HeaderName string            `yaml:"header_name"` // default: X-API-Key
}

// JWTConfig represents JWT authentication configuration
type JWTConfig struct {
        Enabled          bool          `yaml:"enabled"`
        Secret           string        `yaml:"secret"`
        TokenExpiry      time.Duration `yaml:"token_expiry"`
        RefreshExpiry    time.Duration `yaml:"refresh_expiry"`
        Issuer           string        `yaml:"issuer"`
        RequireSignedJWT bool          `yaml:"require_signed_jwt"`
}

// OAuthConfig represents OAuth2 authentication configuration
type OAuthConfig struct {
        Enabled      bool     `yaml:"enabled"`
        Provider     string   `yaml:"provider"` // google, github, custom
        ClientID     string   `yaml:"client_id"`
        ClientSecret string   `yaml:"client_secret"`
        RedirectURL  string   `yaml:"redirect_url"`
        Scopes       []string `yaml:"scopes"`
}

// AuthManager handles authentication and authorization
type AuthManager struct {
        config    AuthConfig
        jwtSecret []byte
}

// UserContext represents an authenticated user
type UserContext struct {
        UserID   string
        Role     string
        APIKey   string
        JWTToken string
        Claims   jwt.MapClaims
}

// Role constants
const (
        RoleAdmin    = "admin"
        RoleMonitor  = "monitor"
        RoleReadOnly = "readonly"
)

// NewAuthManager creates a new authentication manager
func NewAuthManager(config AuthConfig) (*AuthManager, error) <span class="cov8" title="1">{
        am := &amp;AuthManager{
                config: config,
        }

        if config.JWTAuth.Enabled </span><span class="cov8" title="1">{
                if config.JWTAuth.Secret == "" </span><span class="cov0" title="0">{
                        // Generate a random secret if none provided
                        secret := make([]byte, 32)
                        if _, err := rand.Read(secret); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to generate JWT secret: %w", err)
                        }</span>
                        <span class="cov0" title="0">am.jwtSecret = secret</span>
                } else<span class="cov8" title="1"> {
                        am.jwtSecret = []byte(config.JWTAuth.Secret)
                }</span>
        }

        <span class="cov8" title="1">return am, nil</span>
}

// AuthenticateRequest authenticates an HTTP request
func (am *AuthManager) AuthenticateRequest(r *http.Request) (*UserContext, error) <span class="cov8" title="1">{
        if !am.config.Enabled </span><span class="cov8" title="1">{
                // Authentication disabled, allow all requests
                return &amp;UserContext{
                        UserID: "anonymous",
                        Role:   RoleAdmin, // Grant admin role when auth is disabled
                }, nil
        }</span>

        // Try API key authentication first
        <span class="cov8" title="1">if am.config.APIKeyAuth.Enabled </span><span class="cov8" title="1">{
                if userCtx, err := am.authenticateAPIKey(r); err == nil </span><span class="cov8" title="1">{
                        return userCtx, nil
                }</span>
        }

        // Try JWT authentication
        <span class="cov8" title="1">if am.config.JWTAuth.Enabled </span><span class="cov8" title="1">{
                if userCtx, err := am.authenticateJWT(r); err == nil </span><span class="cov8" title="1">{
                        return userCtx, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("authentication required")</span>
}

// authenticateAPIKey authenticates using API key
func (am *AuthManager) authenticateAPIKey(r *http.Request) (*UserContext, error) <span class="cov8" title="1">{
        headerName := am.config.APIKeyAuth.HeaderName
        if headerName == "" </span><span class="cov0" title="0">{
                headerName = "X-API-Key"
        }</span>

        <span class="cov8" title="1">apiKey := r.Header.Get(headerName)
        if apiKey == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("API key not provided")
        }</span>

        // Check if API key exists and get role
        <span class="cov8" title="1">role, exists := am.config.APIKeyAuth.Keys[apiKey]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid API key")
        }</span>

        <span class="cov8" title="1">return &amp;UserContext{
                UserID: fmt.Sprintf("apikey-%s", hashAPIKey(apiKey)),
                Role:   role,
                APIKey: apiKey,
        }, nil</span>
}

// authenticateJWT authenticates using JWT token
func (am *AuthManager) authenticateJWT(r *http.Request) (*UserContext, error) <span class="cov8" title="1">{
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("authorization header not provided")
        }</span>

        // Extract Bearer token
        <span class="cov8" title="1">parts := strings.SplitN(authHeader, " ", 2)
        if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid authorization header format")
        }</span>

        <span class="cov8" title="1">tokenString := parts[1]

        // Parse and validate JWT token
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                // Validate signing method
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov8" title="1">return am.jwtSecret, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid JWT token: %w", err)
        }</span>

        <span class="cov8" title="1">if !token.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid JWT token")
        }</span>

        <span class="cov8" title="1">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid JWT claims")
        }</span>

        // Extract user information from claims
        <span class="cov8" title="1">userID, _ := claims["sub"].(string)
        role, _ := claims["role"].(string)

        if userID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user ID not found in JWT claims")
        }</span>

        <span class="cov8" title="1">if role == "" </span><span class="cov0" title="0">{
                role = RoleReadOnly // Default role
        }</span>

        <span class="cov8" title="1">return &amp;UserContext{
                UserID:   userID,
                Role:     role,
                JWTToken: tokenString,
                Claims:   claims,
        }, nil</span>
}

// Authorize checks if user has required permissions
func (am *AuthManager) Authorize(userCtx *UserContext, requiredRole string) error <span class="cov8" title="1">{
        if !am.config.Enabled </span><span class="cov8" title="1">{
                return nil // Authorization disabled
        }</span>

        // Check if user has required role
        <span class="cov8" title="1">if !am.hasRole(userCtx.Role, requiredRole) </span><span class="cov8" title="1">{
                return fmt.Errorf("insufficient permissions: required role %s, user has %s", requiredRole, userCtx.Role)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// hasRole checks if user role satisfies required role
func (am *AuthManager) hasRole(userRole, requiredRole string) bool <span class="cov8" title="1">{
        roleHierarchy := map[string]int{
                RoleReadOnly: 1,
                RoleMonitor:  2,
                RoleAdmin:    3,
        }

        userLevel, userExists := roleHierarchy[userRole]
        requiredLevel, requiredExists := roleHierarchy[requiredRole]

        if !userExists || !requiredExists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return userLevel &gt;= requiredLevel</span>
}

// GenerateJWT generates a JWT token for a user
func (am *AuthManager) GenerateJWT(userID, role string) (string, error) <span class="cov8" title="1">{
        if !am.config.JWTAuth.Enabled </span><span class="cov0" title="0">{
                return "", fmt.Errorf("JWT authentication not enabled")
        }</span>

        <span class="cov8" title="1">now := time.Now()
        claims := jwt.MapClaims{
                "sub":  userID,
                "role": role,
                "iat":  now.Unix(),
                "exp":  now.Add(am.config.JWTAuth.TokenExpiry).Unix(),
                "iss":  am.config.JWTAuth.Issuer,
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(am.jwtSecret)</span>
}

// GenerateAPIKey generates a new API key
func (am *AuthManager) GenerateAPIKey() (string, error) <span class="cov8" title="1">{
        keyBytes := make([]byte, 32)
        if _, err := rand.Read(keyBytes); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate API key: %w", err)
        }</span>
        <span class="cov8" title="1">return base64.URLEncoding.EncodeToString(keyBytes), nil</span>
}

// AuthMiddleware returns an HTTP middleware for authentication
func (am *AuthManager) AuthMiddleware(requiredRole string) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        // Skip authentication for health check
                        if r.URL.Path == "/api/v1/health" </span><span class="cov8" title="1">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov8" title="1">userCtx, err := am.AuthenticateRequest(r)
                        if err != nil </span><span class="cov8" title="1">{
                                http.Error(w, fmt.Sprintf("Authentication failed: %v", err), http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov8" title="1">if err := am.Authorize(userCtx, requiredRole); err != nil </span><span class="cov0" title="0">{
                                http.Error(w, fmt.Sprintf("Authorization failed: %v", err), http.StatusForbidden)
                                return
                        }</span>

                        // Add user context to request
                        <span class="cov8" title="1">ctx := context.WithValue(r.Context(), "user", userCtx)
                        next.ServeHTTP(w, r.WithContext(ctx))</span>
                })
        }
}

// GetUserFromContext extracts user context from request context
func GetUserFromContext(ctx context.Context) (*UserContext, bool) <span class="cov8" title="1">{
        user, ok := ctx.Value("user").(*UserContext)
        return user, ok
}</span>

// hashAPIKey creates a hash of the API key for logging purposes
func hashAPIKey(apiKey string) string <span class="cov8" title="1">{
        if len(apiKey) &lt; 8 </span><span class="cov0" title="0">{
                return "short"
        }</span>
        <span class="cov8" title="1">return apiKey[:4] + "****" + apiKey[len(apiKey)-4:]</span>
}

// ValidateRole checks if a role is valid
func ValidateRole(role string) bool <span class="cov8" title="1">{
        switch role </span>{
        case RoleAdmin, RoleMonitor, RoleReadOnly:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// CompareAPIKeys performs constant-time comparison of API keys
func CompareAPIKeys(provided, stored string) bool <span class="cov0" title="0">{
        return subtle.ConstantTimeCompare([]byte(provided), []byte(stored)) == 1
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package monitoring

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/ishaileshpant/fl-go/pkg/federation"
)

// MonitoringHooks provides integration points for FL components to send metrics
type MonitoringHooks struct {
        service MonitoringService
        enabled bool
}

// NewMonitoringHooks creates a new monitoring hooks instance
func NewMonitoringHooks(service MonitoringService, enabled bool) *MonitoringHooks <span class="cov0" title="0">{
        return &amp;MonitoringHooks{
                service: service,
                enabled: enabled,
        }
}</span>

// IsEnabled returns whether monitoring is enabled
func (h *MonitoringHooks) IsEnabled() bool <span class="cov0" title="0">{
        return h.enabled
}</span>

// Federation Lifecycle Hooks

// OnFederationStart records the start of a federation
func (h *MonitoringHooks) OnFederationStart(ctx context.Context, plan *federation.FLPlan, aggregatorAddress string) error <span class="cov0" title="0">{
        if !h.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">metrics := &amp;FederationMetrics{
                ID:                fmt.Sprintf("fed_%d", time.Now().Unix()),
                Name:              fmt.Sprintf("Federation_%s", plan.Algorithm.Name),
                Status:            StatusRunning,
                Mode:              string(plan.Mode),
                Algorithm:         plan.Algorithm.Name,
                StartTime:         time.Now(),
                CurrentRound:      0,
                TotalRounds:       plan.Rounds,
                ActiveCollabs:     0,
                TotalCollabs:      len(plan.Collaborators),
                ModelSize:         0, // Will be updated when first model is loaded
                LastUpdate:        time.Now(),
                AggregatorAddress: aggregatorAddress,
        }

        if err := h.service.RegisterFederation(ctx, metrics); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to record federation start: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OnFederationEnd records the completion or failure of a federation
func (h *MonitoringHooks) OnFederationEnd(ctx context.Context, federationID string, status FederationStatus, endTime time.Time) error <span class="cov0" title="0">{
        if !h.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get current federation metrics
        <span class="cov0" title="0">currentMetrics, err := h.service.GetFederation(ctx, federationID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update status and end time
        <span class="cov0" title="0">currentMetrics.Status = status
        currentMetrics.EndTime = &amp;endTime
        currentMetrics.LastUpdate = time.Now()

        if err := h.service.UpdateFederation(ctx, federationID, currentMetrics); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to record federation end: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Round Lifecycle Hooks

// OnRoundStart records the start of a training round
func (h *MonitoringHooks) OnRoundStart(ctx context.Context, federationID string, roundNumber int, algorithm string, participantCount int) (string, error) <span class="cov0" title="0">{
        if !h.enabled </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">roundID := fmt.Sprintf("round_%s_%d", federationID, roundNumber)
        metrics := &amp;RoundMetrics{
                ID:               roundID,
                FederationID:     federationID,
                RoundNumber:      roundNumber,
                Algorithm:        algorithm,
                StartTime:        time.Now(),
                ParticipantCount: participantCount,
                UpdatesReceived:  0,
                Status:           "running",
        }

        if err := h.service.RecordRoundStart(ctx, metrics); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to record round start: %v", err)
                return "", err
        }</span>

        // Update federation current round
        <span class="cov0" title="0">if err := h.updateFederationRound(ctx, federationID, roundNumber); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update federation round: %v", err)
        }</span>

        <span class="cov0" title="0">return roundID, nil</span>
}

// OnRoundEnd records the completion of a training round
func (h *MonitoringHooks) OnRoundEnd(ctx context.Context, roundID string, federationID string, roundNumber int, duration time.Duration, updatesReceived int, accuracy *float64, loss *float64) error <span class="cov0" title="0">{
        if !h.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">endTime := time.Now()
        metrics := &amp;RoundMetrics{
                ID:              roundID,
                FederationID:    federationID,
                RoundNumber:     roundNumber,
                EndTime:         &amp;endTime,
                Duration:        duration,
                UpdatesReceived: updatesReceived,
                ModelAccuracy:   accuracy,
                ModelLoss:       loss,
                Status:          "completed",
        }

        if err := h.service.RecordRoundEnd(ctx, roundID, metrics); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to record round end: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Collaborator Lifecycle Hooks

// OnCollaboratorJoin records when a collaborator joins a federation
func (h *MonitoringHooks) OnCollaboratorJoin(ctx context.Context, collaboratorID, federationID, address string) error <span class="cov0" title="0">{
        if !h.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">metrics := &amp;CollaboratorMetrics{
                ID:               collaboratorID,
                FederationID:     federationID,
                Address:          address,
                Status:           CollabStatusConnected,
                JoinTime:         time.Now(),
                LastSeen:         time.Now(),
                CurrentRound:     0,
                UpdatesSubmitted: 0,
                ErrorCount:       0,
        }

        if err := h.service.RegisterCollaborator(ctx, metrics); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to record collaborator join: %v", err)
                return err
        }</span>

        // Update federation active collaborator count
        <span class="cov0" title="0">if err := h.updateFederationCollaboratorCount(ctx, federationID); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update federation collaborator count: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OnCollaboratorLeave records when a collaborator leaves a federation
func (h *MonitoringHooks) OnCollaboratorLeave(ctx context.Context, collaboratorID string, reason string) error <span class="cov0" title="0">{
        if !h.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get current collaborator metrics
        <span class="cov0" title="0">currentMetrics, err := h.service.GetCollaborator(ctx, collaboratorID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update status
        <span class="cov0" title="0">currentMetrics.Status = CollabStatusDisconnected
        currentMetrics.LastSeen = time.Now()
        if reason != "" </span><span class="cov0" title="0">{
                currentMetrics.LastError = reason
        }</span>

        <span class="cov0" title="0">if err := h.service.UpdateCollaborator(ctx, collaboratorID, currentMetrics); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to record collaborator leave: %v", err)
                return err
        }</span>

        // Update federation active collaborator count
        <span class="cov0" title="0">if err := h.updateFederationCollaboratorCount(ctx, currentMetrics.FederationID); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update federation collaborator count: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// OnCollaboratorStatusChange records when a collaborator's status changes
func (h *MonitoringHooks) OnCollaboratorStatusChange(ctx context.Context, collaboratorID string, status CollaboratorStatus, errorMsg string) error <span class="cov0" title="0">{
        if !h.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get current collaborator metrics
        <span class="cov0" title="0">currentMetrics, err := h.service.GetCollaborator(ctx, collaboratorID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update status
        <span class="cov0" title="0">currentMetrics.Status = status
        currentMetrics.LastSeen = time.Now()

        if status == CollabStatusError </span><span class="cov0" title="0">{
                currentMetrics.ErrorCount++
                if errorMsg != "" </span><span class="cov0" title="0">{
                        currentMetrics.LastError = errorMsg
                }</span>
        }

        <span class="cov0" title="0">if err := h.service.UpdateCollaborator(ctx, collaboratorID, currentMetrics); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update collaborator status: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Model Update Hooks

// OnModelUpdateReceived records when a model update is received
func (h *MonitoringHooks) OnModelUpdateReceived(ctx context.Context, federationID, collaboratorID string, roundNumber int, updateSize int, processingTime time.Duration, staleness int, weight float64) error <span class="cov0" title="0">{
        if !h.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">metrics := &amp;ModelUpdateMetrics{
                FederationID:   federationID,
                CollaboratorID: collaboratorID,
                RoundNumber:    roundNumber,
                Timestamp:      time.Now(),
                UpdateSize:     updateSize,
                ProcessingTime: float64(processingTime.Milliseconds()),
                Staleness:      staleness,
                Weight:         weight,
        }

        if err := h.service.RecordModelUpdate(ctx, metrics); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to record model update: %v", err)
                return err
        }</span>

        // Update collaborator metrics
        <span class="cov0" title="0">if err := h.updateCollaboratorUpdate(ctx, collaboratorID, roundNumber, processingTime); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update collaborator update metrics: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Aggregation Hooks

// OnAggregationStart records when aggregation starts
func (h *MonitoringHooks) OnAggregationStart(ctx context.Context, federationID string, roundNumber int, algorithm string, updatesCount int) (string, error) <span class="cov0" title="0">{
        if !h.enabled </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">aggregationID := fmt.Sprintf("agg_%s_%d_%d", federationID, roundNumber, time.Now().Unix())
        metrics := &amp;AggregationMetrics{
                ID:                aggregationID,
                FederationID:      federationID,
                RoundNumber:       roundNumber,
                Algorithm:         algorithm,
                StartTime:         time.Now(),
                UpdatesAggregated: updatesCount,
        }

        if err := h.service.RecordAggregation(ctx, metrics); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to record aggregation start: %v", err)
                return "", err
        }</span>

        <span class="cov0" title="0">return aggregationID, nil</span>
}

// OnAggregationEnd records when aggregation completes
func (h *MonitoringHooks) OnAggregationEnd(ctx context.Context, aggregationID string, duration time.Duration, convergence *float64, quality *float64) error <span class="cov0" title="0">{
        if !h.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        // This would need to be implemented to update the existing aggregation record
        // For now, we'll create a new record with the completion data
        <span class="cov0" title="0">endTime := time.Now()

        // In a real implementation, you'd update the existing record
        // Here we're showing the data structure for completion
        _ = &amp;AggregationMetrics{
                ID:                 aggregationID,
                EndTime:            endTime,
                Duration:           duration,
                ModelConvergence:   convergence,
                AggregationQuality: quality,
        }

        // Log completion for now
        log.Printf("Aggregation %s completed in %v", aggregationID, duration)

        return nil</span>
}

// Resource Monitoring Hooks

// OnResourceMetrics records system resource usage
func (h *MonitoringHooks) OnResourceMetrics(ctx context.Context, source string, cpuUsage, memoryUsage, diskUsage float64, memoryUsed, memoryTotal int64, networkRx, networkTx float64) error <span class="cov0" title="0">{
        if !h.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">metrics := &amp;ResourceMetrics{
                Timestamp:     time.Now(),
                CPUUsage:      cpuUsage,
                MemoryUsage:   memoryUsage,
                MemoryUsed:    memoryUsed,
                MemoryTotal:   memoryTotal,
                DiskUsage:     diskUsage,
                NetworkRxRate: networkRx,
                NetworkTxRate: networkTx,
        }

        if err := h.service.RecordResourceMetrics(ctx, source, metrics); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to record resource metrics: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Event Hooks

// OnEvent records a monitoring event
func (h *MonitoringHooks) OnEvent(ctx context.Context, federationID, source, level, message string, eventType MetricType, data map[string]interface{}) error <span class="cov0" title="0">{
        if !h.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">event := &amp;MonitoringEvent{
                FederationID: federationID,
                Type:         eventType,
                Timestamp:    time.Now(),
                Source:       source,
                Level:        level,
                Message:      message,
                Data:         data,
        }

        if err := h.service.RecordEvent(ctx, event); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to record event: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Alert Hooks

// OnAlert creates an alert for significant events
func (h *MonitoringHooks) OnAlert(ctx context.Context, federationID, alertType, severity, title, message, source string, data map[string]interface{}) error <span class="cov0" title="0">{
        if !h.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        // For now, log the alert - in a real implementation, this would create an alert record
        <span class="cov0" title="0">log.Printf("ALERT [%s] %s: %s - %s", severity, title, message, source)

        // Also record as an event
        return h.OnEvent(ctx, federationID, source, "alert", fmt.Sprintf("[%s] %s: %s", severity, title, message), MetricTypeRound, data)</span>
}

// Training Performance Hooks

// OnTrainingStart records when training starts on a collaborator
func (h *MonitoringHooks) OnTrainingStart(ctx context.Context, collaboratorID string, roundNumber int) error <span class="cov0" title="0">{
        if !h.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return h.OnCollaboratorStatusChange(ctx, collaboratorID, CollabStatusTraining, "")</span>
}

// OnTrainingEnd records when training completes on a collaborator
func (h *MonitoringHooks) OnTrainingEnd(ctx context.Context, collaboratorID string, roundNumber int, duration time.Duration, accuracy *float64, loss *float64) error <span class="cov0" title="0">{
        if !h.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Update collaborator training time
        <span class="cov0" title="0">currentMetrics, err := h.service.GetCollaborator(ctx, collaboratorID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">currentMetrics.TrainingTime += duration
        currentMetrics.Status = CollabStatusIdle
        currentMetrics.CurrentRound = roundNumber
        currentMetrics.LastSeen = time.Now()

        if err := h.service.UpdateCollaborator(ctx, collaboratorID, currentMetrics); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to update collaborator training metrics: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Helper methods for updating related metrics

func (h *MonitoringHooks) updateFederationRound(ctx context.Context, federationID string, roundNumber int) error <span class="cov0" title="0">{
        currentMetrics, err := h.service.GetFederation(ctx, federationID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">currentMetrics.CurrentRound = roundNumber
        currentMetrics.LastUpdate = time.Now()

        return h.service.UpdateFederation(ctx, federationID, currentMetrics)</span>
}

func (h *MonitoringHooks) updateFederationCollaboratorCount(ctx context.Context, federationID string) error <span class="cov0" title="0">{
        collaborators, err := h.service.GetFederationCollaborators(ctx, federationID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">activeCount := 0
        for _, collab := range collaborators </span><span class="cov0" title="0">{
                if collab.Status == CollabStatusConnected || collab.Status == CollabStatusTraining </span><span class="cov0" title="0">{
                        activeCount++
                }</span>
        }

        <span class="cov0" title="0">currentMetrics, err := h.service.GetFederation(ctx, federationID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">currentMetrics.ActiveCollabs = activeCount
        currentMetrics.LastUpdate = time.Now()

        return h.service.UpdateFederation(ctx, federationID, currentMetrics)</span>
}

func (h *MonitoringHooks) updateCollaboratorUpdate(ctx context.Context, collaboratorID string, roundNumber int, latency time.Duration) error <span class="cov0" title="0">{
        currentMetrics, err := h.service.GetCollaborator(ctx, collaboratorID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">currentMetrics.UpdatesSubmitted++
        currentMetrics.CurrentRound = roundNumber
        currentMetrics.LastSeen = time.Now()

        // Update average latency (simple moving average)
        if currentMetrics.AverageLatency == 0 </span><span class="cov0" title="0">{
                currentMetrics.AverageLatency = float64(latency.Milliseconds())
        }</span> else<span class="cov0" title="0"> {
                currentMetrics.AverageLatency = (currentMetrics.AverageLatency + float64(latency.Milliseconds())) / 2
        }</span>

        <span class="cov0" title="0">return h.service.UpdateCollaborator(ctx, collaboratorID, currentMetrics)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package monitoring

import (
        "context"
        "fmt"
        "sort"
        "sync"
        "time"

        "github.com/google/uuid"
)

// MemoryStorage implements MonitoringService using in-memory storage
type MemoryStorage struct {
        mu              sync.RWMutex
        federations     map[string]*FederationMetrics
        collaborators   map[string]*CollaboratorMetrics
        rounds          map[string]*RoundMetrics
        modelUpdates    []*ModelUpdateMetrics
        aggregations    []*AggregationMetrics
        resourceMetrics map[string][]*ResourceMetrics // key: source (aggregator/collaborator ID)
        events          []*MonitoringEvent
        alerts          []*Alert
        dashboards      map[string]*Dashboard
        subscriptions   map[string]*EventSubscription
        config          *MonitoringConfig
        startTime       time.Time
}

// NewMemoryStorage creates a new in-memory storage instance
func NewMemoryStorage(config *MonitoringConfig) *MemoryStorage <span class="cov0" title="0">{
        return &amp;MemoryStorage{
                federations:     make(map[string]*FederationMetrics),
                collaborators:   make(map[string]*CollaboratorMetrics),
                rounds:          make(map[string]*RoundMetrics),
                modelUpdates:    make([]*ModelUpdateMetrics, 0),
                aggregations:    make([]*AggregationMetrics, 0),
                resourceMetrics: make(map[string][]*ResourceMetrics),
                events:          make([]*MonitoringEvent, 0),
                alerts:          make([]*Alert, 0),
                dashboards:      make(map[string]*Dashboard),
                subscriptions:   make(map[string]*EventSubscription),
                config:          config,
                startTime:       time.Now(),
        }
}</span>

// Federation metrics implementation
func (m *MemoryStorage) RegisterFederation(ctx context.Context, metrics *FederationMetrics) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.federations[metrics.ID] = metrics

        // Record event
        event := &amp;MonitoringEvent{
                ID:           uuid.New().String(),
                FederationID: metrics.ID,
                Type:         MetricTypeRound,
                Timestamp:    time.Now(),
                Source:       "aggregator",
                Level:        "info",
                Message:      fmt.Sprintf("Federation %s registered", metrics.Name),
                Data: map[string]interface{}{
                        "mode":      metrics.Mode,
                        "algorithm": metrics.Algorithm,
                        "rounds":    metrics.TotalRounds,
                },
        }
        m.events = append(m.events, event)
        m.notifySubscribers(event)

        return nil
}</span>

func (m *MemoryStorage) UpdateFederation(ctx context.Context, federationID string, metrics *FederationMetrics) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if _, exists := m.federations[federationID]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("federation %s not found", federationID)
        }</span>

        <span class="cov0" title="0">metrics.ID = federationID
        m.federations[federationID] = metrics

        return nil</span>
}

func (m *MemoryStorage) GetFederation(ctx context.Context, federationID string) (*FederationMetrics, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        federation, exists := m.federations[federationID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("federation %s not found", federationID)
        }</span>

        // Return a copy to prevent external modification
        <span class="cov0" title="0">result := *federation
        return &amp;result, nil</span>
}

func (m *MemoryStorage) GetActiveFederations(ctx context.Context) ([]*FederationMetrics, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var active []*FederationMetrics
        for _, federation := range m.federations </span><span class="cov0" title="0">{
                if federation.Status == StatusRunning </span><span class="cov0" title="0">{
                        // Return a copy
                        result := *federation
                        active = append(active, &amp;result)
                }</span>
        }

        <span class="cov0" title="0">return active, nil</span>
}

func (m *MemoryStorage) GetFederationHistory(ctx context.Context, filter *MetricsFilter) ([]*FederationMetrics, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var results []*FederationMetrics
        for _, federation := range m.federations </span><span class="cov0" title="0">{
                if m.matchesFederationFilter(federation, filter) </span><span class="cov0" title="0">{
                        result := *federation
                        results = append(results, &amp;result)
                }</span>
        }

        // Sort by start time
        <span class="cov0" title="0">sort.Slice(results, func(i, j int) bool </span><span class="cov0" title="0">{
                return results[i].StartTime.After(results[j].StartTime)
        }</span>)

        <span class="cov0" title="0">return m.paginateFederations(results, filter), nil</span>
}

// Collaborator metrics implementation
func (m *MemoryStorage) RegisterCollaborator(ctx context.Context, metrics *CollaboratorMetrics) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.collaborators[metrics.ID] = metrics

        // Record event
        event := &amp;MonitoringEvent{
                ID:           uuid.New().String(),
                FederationID: metrics.FederationID,
                Type:         MetricTypeCollaborator,
                Timestamp:    time.Now(),
                Source:       metrics.ID,
                Level:        "info",
                Message:      fmt.Sprintf("Collaborator %s joined federation", metrics.ID),
                Data: map[string]interface{}{
                        "address": metrics.Address,
                        "status":  metrics.Status,
                },
        }
        m.events = append(m.events, event)
        m.notifySubscribers(event)

        return nil
}</span>

func (m *MemoryStorage) UpdateCollaborator(ctx context.Context, collaboratorID string, metrics *CollaboratorMetrics) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if _, exists := m.collaborators[collaboratorID]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("collaborator %s not found", collaboratorID)
        }</span>

        <span class="cov0" title="0">metrics.ID = collaboratorID
        m.collaborators[collaboratorID] = metrics

        return nil</span>
}

func (m *MemoryStorage) GetCollaborator(ctx context.Context, collaboratorID string) (*CollaboratorMetrics, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        collaborator, exists := m.collaborators[collaboratorID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("collaborator %s not found", collaboratorID)
        }</span>

        <span class="cov0" title="0">result := *collaborator
        return &amp;result, nil</span>
}

func (m *MemoryStorage) GetFederationCollaborators(ctx context.Context, federationID string) ([]*CollaboratorMetrics, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var collaborators []*CollaboratorMetrics
        for _, collaborator := range m.collaborators </span><span class="cov0" title="0">{
                if collaborator.FederationID == federationID </span><span class="cov0" title="0">{
                        result := *collaborator
                        collaborators = append(collaborators, &amp;result)
                }</span>
        }

        <span class="cov0" title="0">return collaborators, nil</span>
}

func (m *MemoryStorage) GetCollaboratorHistory(ctx context.Context, filter *MetricsFilter) ([]*CollaboratorMetrics, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var results []*CollaboratorMetrics
        for _, collaborator := range m.collaborators </span><span class="cov0" title="0">{
                if m.matchesCollaboratorFilter(collaborator, filter) </span><span class="cov0" title="0">{
                        result := *collaborator
                        results = append(results, &amp;result)
                }</span>
        }

        // Sort by join time
        <span class="cov0" title="0">sort.Slice(results, func(i, j int) bool </span><span class="cov0" title="0">{
                return results[i].JoinTime.After(results[j].JoinTime)
        }</span>)

        <span class="cov0" title="0">return m.paginateCollaborators(results, filter), nil</span>
}

// Round metrics implementation
func (m *MemoryStorage) RecordRoundStart(ctx context.Context, metrics *RoundMetrics) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if metrics.ID == "" </span><span class="cov0" title="0">{
                metrics.ID = uuid.New().String()
        }</span>

        <span class="cov0" title="0">m.rounds[metrics.ID] = metrics

        // Record event
        event := &amp;MonitoringEvent{
                ID:           uuid.New().String(),
                FederationID: metrics.FederationID,
                Type:         MetricTypeRound,
                Timestamp:    time.Now(),
                Source:       "aggregator",
                Level:        "info",
                Message:      fmt.Sprintf("Round %d started", metrics.RoundNumber),
                Data: map[string]interface{}{
                        "round_id":     metrics.ID,
                        "algorithm":    metrics.Algorithm,
                        "participants": metrics.ParticipantCount,
                },
        }
        m.events = append(m.events, event)
        m.notifySubscribers(event)

        return nil</span>
}

func (m *MemoryStorage) RecordRoundEnd(ctx context.Context, roundID string, metrics *RoundMetrics) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if _, exists := m.rounds[roundID]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("round %s not found", roundID)
        }</span>

        <span class="cov0" title="0">metrics.ID = roundID
        m.rounds[roundID] = metrics

        // Record event
        event := &amp;MonitoringEvent{
                ID:           uuid.New().String(),
                FederationID: metrics.FederationID,
                Type:         MetricTypeRound,
                Timestamp:    time.Now(),
                Source:       "aggregator",
                Level:        "info",
                Message:      fmt.Sprintf("Round %d completed", metrics.RoundNumber),
                Data: map[string]interface{}{
                        "round_id":     metrics.ID,
                        "duration_ms":  metrics.Duration.Milliseconds(),
                        "participants": metrics.ParticipantCount,
                        "updates":      metrics.UpdatesReceived,
                },
        }
        m.events = append(m.events, event)
        m.notifySubscribers(event)

        return nil</span>
}

func (m *MemoryStorage) GetRound(ctx context.Context, roundID string) (*RoundMetrics, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        round, exists := m.rounds[roundID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("round %s not found", roundID)
        }</span>

        <span class="cov0" title="0">result := *round
        return &amp;result, nil</span>
}

func (m *MemoryStorage) GetFederationRounds(ctx context.Context, federationID string) ([]*RoundMetrics, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var rounds []*RoundMetrics
        for _, round := range m.rounds </span><span class="cov0" title="0">{
                if round.FederationID == federationID </span><span class="cov0" title="0">{
                        result := *round
                        rounds = append(rounds, &amp;result)
                }</span>
        }

        // Sort by round number
        <span class="cov0" title="0">sort.Slice(rounds, func(i, j int) bool </span><span class="cov0" title="0">{
                return rounds[i].RoundNumber &lt; rounds[j].RoundNumber
        }</span>)

        <span class="cov0" title="0">return rounds, nil</span>
}

func (m *MemoryStorage) GetRoundHistory(ctx context.Context, filter *MetricsFilter) ([]*RoundMetrics, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var results []*RoundMetrics
        for _, round := range m.rounds </span><span class="cov0" title="0">{
                if m.matchesRoundFilter(round, filter) </span><span class="cov0" title="0">{
                        result := *round
                        results = append(results, &amp;result)
                }</span>
        }

        // Sort by start time
        <span class="cov0" title="0">sort.Slice(results, func(i, j int) bool </span><span class="cov0" title="0">{
                return results[i].StartTime.After(results[j].StartTime)
        }</span>)

        <span class="cov0" title="0">return m.paginateRounds(results, filter), nil</span>
}

// Model update metrics implementation
func (m *MemoryStorage) RecordModelUpdate(ctx context.Context, metrics *ModelUpdateMetrics) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if metrics.ID == "" </span><span class="cov0" title="0">{
                metrics.ID = uuid.New().String()
        }</span>

        <span class="cov0" title="0">m.modelUpdates = append(m.modelUpdates, metrics)

        // Record event
        event := &amp;MonitoringEvent{
                ID:           uuid.New().String(),
                FederationID: metrics.FederationID,
                Type:         MetricTypeModelUpdate,
                Timestamp:    time.Now(),
                Source:       metrics.CollaboratorID,
                Level:        "info",
                Message:      fmt.Sprintf("Model update received from %s", metrics.CollaboratorID),
                Data: map[string]interface{}{
                        "round":         metrics.RoundNumber,
                        "size_bytes":    metrics.UpdateSize,
                        "processing_ms": metrics.ProcessingTime,
                },
        }
        m.events = append(m.events, event)
        m.notifySubscribers(event)

        return nil</span>
}

func (m *MemoryStorage) GetModelUpdates(ctx context.Context, filter *MetricsFilter) ([]*ModelUpdateMetrics, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var results []*ModelUpdateMetrics
        for _, update := range m.modelUpdates </span><span class="cov0" title="0">{
                if m.matchesUpdateFilter(update, filter) </span><span class="cov0" title="0">{
                        result := *update
                        results = append(results, &amp;result)
                }</span>
        }

        // Sort by timestamp
        <span class="cov0" title="0">sort.Slice(results, func(i, j int) bool </span><span class="cov0" title="0">{
                return results[i].Timestamp.After(results[j].Timestamp)
        }</span>)

        <span class="cov0" title="0">return m.paginateUpdates(results, filter), nil</span>
}

func (m *MemoryStorage) GetUpdateStatistics(ctx context.Context, federationID string, roundNumber int) (*UpdateStatistics, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var updates []*ModelUpdateMetrics
        for _, update := range m.modelUpdates </span><span class="cov0" title="0">{
                if update.FederationID == federationID &amp;&amp; update.RoundNumber == roundNumber </span><span class="cov0" title="0">{
                        updates = append(updates, update)
                }</span>
        }

        <span class="cov0" title="0">if len(updates) == 0 </span><span class="cov0" title="0">{
                return &amp;UpdateStatistics{}, nil
        }</span>

        // Calculate statistics
        <span class="cov0" title="0">stats := &amp;UpdateStatistics{
                TotalUpdates: len(updates),
        }

        var totalLatency, totalSize, totalQuality, totalCompression float64
        successCount := 0

        for _, update := range updates </span><span class="cov0" title="0">{
                totalLatency += update.ProcessingTime
                totalSize += float64(update.UpdateSize)
                if update.QualityScore != nil </span><span class="cov0" title="0">{
                        totalQuality += *update.QualityScore
                }</span>
                <span class="cov0" title="0">if update.CompressionRatio != nil </span><span class="cov0" title="0">{
                        totalCompression += *update.CompressionRatio
                }</span>
                <span class="cov0" title="0">successCount++</span> // Assuming all recorded updates are successful
        }

        <span class="cov0" title="0">stats.AverageLatency = totalLatency / float64(len(updates))
        stats.AverageSize = totalSize / float64(len(updates))
        stats.SuccessRate = float64(successCount) / float64(len(updates)) * 100
        stats.QualityScore = totalQuality / float64(len(updates))
        stats.CompressionRatio = totalCompression / float64(len(updates))

        return stats, nil</span>
}

// Aggregation metrics implementation
func (m *MemoryStorage) RecordAggregation(ctx context.Context, metrics *AggregationMetrics) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if metrics.ID == "" </span><span class="cov0" title="0">{
                metrics.ID = uuid.New().String()
        }</span>

        <span class="cov0" title="0">m.aggregations = append(m.aggregations, metrics)

        // Record event
        event := &amp;MonitoringEvent{
                ID:           uuid.New().String(),
                FederationID: metrics.FederationID,
                Type:         MetricTypeAggregation,
                Timestamp:    time.Now(),
                Source:       "aggregator",
                Level:        "info",
                Message:      fmt.Sprintf("Aggregation completed for round %d", metrics.RoundNumber),
                Data: map[string]interface{}{
                        "algorithm":   metrics.Algorithm,
                        "duration_ms": metrics.Duration.Milliseconds(),
                        "updates":     metrics.UpdatesAggregated,
                },
        }
        m.events = append(m.events, event)
        m.notifySubscribers(event)

        return nil</span>
}

func (m *MemoryStorage) GetAggregations(ctx context.Context, filter *MetricsFilter) ([]*AggregationMetrics, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var results []*AggregationMetrics
        for _, aggregation := range m.aggregations </span><span class="cov0" title="0">{
                if m.matchesAggregationFilter(aggregation, filter) </span><span class="cov0" title="0">{
                        result := *aggregation
                        results = append(results, &amp;result)
                }</span>
        }

        // Sort by start time
        <span class="cov0" title="0">sort.Slice(results, func(i, j int) bool </span><span class="cov0" title="0">{
                return results[i].StartTime.After(results[j].StartTime)
        }</span>)

        <span class="cov0" title="0">return m.paginateAggregations(results, filter), nil</span>
}

func (m *MemoryStorage) GetAggregationStatistics(ctx context.Context, federationID string) (*AggregationStatistics, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var aggregations []*AggregationMetrics
        for _, agg := range m.aggregations </span><span class="cov0" title="0">{
                if agg.FederationID == federationID </span><span class="cov0" title="0">{
                        aggregations = append(aggregations, agg)
                }</span>
        }

        <span class="cov0" title="0">if len(aggregations) == 0 </span><span class="cov0" title="0">{
                return &amp;AggregationStatistics{}, nil
        }</span>

        // Calculate statistics
        <span class="cov0" title="0">stats := &amp;AggregationStatistics{
                TotalAggregations: len(aggregations),
        }

        var totalTime, totalParticipants, totalConvergence, totalQuality float64

        for _, agg := range aggregations </span><span class="cov0" title="0">{
                totalTime += float64(agg.Duration.Milliseconds())
                totalParticipants += float64(agg.UpdatesAggregated)
                if agg.ModelConvergence != nil </span><span class="cov0" title="0">{
                        totalConvergence += *agg.ModelConvergence
                }</span>
                <span class="cov0" title="0">if agg.AggregationQuality != nil </span><span class="cov0" title="0">{
                        totalQuality += *agg.AggregationQuality
                }</span>
        }

        <span class="cov0" title="0">stats.AverageTime = totalTime / float64(len(aggregations))
        stats.AverageParticipants = totalParticipants / float64(len(aggregations))
        stats.ConvergenceRate = totalConvergence / float64(len(aggregations))
        stats.ModelQuality = totalQuality / float64(len(aggregations))

        return stats, nil</span>
}

// Resource metrics implementation
func (m *MemoryStorage) RecordResourceMetrics(ctx context.Context, source string, metrics *ResourceMetrics) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.resourceMetrics[source] == nil </span><span class="cov0" title="0">{
                m.resourceMetrics[source] = make([]*ResourceMetrics, 0)
        }</span>

        <span class="cov0" title="0">m.resourceMetrics[source] = append(m.resourceMetrics[source], metrics)

        // Keep only recent metrics to prevent memory overflow
        maxMetrics := 1000 // Keep last 1000 metrics per source
        if len(m.resourceMetrics[source]) &gt; maxMetrics </span><span class="cov0" title="0">{
                m.resourceMetrics[source] = m.resourceMetrics[source][len(m.resourceMetrics[source])-maxMetrics:]
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *MemoryStorage) GetResourceMetrics(ctx context.Context, source string, timeRange time.Duration) ([]*ResourceMetrics, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        metrics, exists := m.resourceMetrics[source]
        if !exists </span><span class="cov0" title="0">{
                return []*ResourceMetrics{}, nil
        }</span>

        <span class="cov0" title="0">cutoff := time.Now().Add(-timeRange)
        var results []*ResourceMetrics

        for _, metric := range metrics </span><span class="cov0" title="0">{
                if metric.Timestamp.After(cutoff) </span><span class="cov0" title="0">{
                        result := *metric
                        results = append(results, &amp;result)
                }</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

func (m *MemoryStorage) GetSystemOverview(ctx context.Context, federationID string) (*SystemOverview, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        federation, exists := m.federations[federationID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("federation %s not found", federationID)
        }</span>

        // Get collaborators for this federation
        <span class="cov0" title="0">var totalCollabs, activeCollabs int
        for _, collab := range m.collaborators </span><span class="cov0" title="0">{
                if collab.FederationID == federationID </span><span class="cov0" title="0">{
                        totalCollabs++
                        if collab.Status == CollabStatusConnected || collab.Status == CollabStatusTraining </span><span class="cov0" title="0">{
                                activeCollabs++
                        }</span>
                }
        }

        // Calculate progress
        <span class="cov0" title="0">progress := float64(federation.CurrentRound) / float64(federation.TotalRounds) * 100
        if federation.TotalRounds == 0 </span><span class="cov0" title="0">{
                progress = 0
        }</span>

        // Get recent events
        <span class="cov0" title="0">var recentEvents []*MonitoringEvent
        eventCount := 0
        for i := len(m.events) - 1; i &gt;= 0 &amp;&amp; eventCount &lt; 10; i-- </span><span class="cov0" title="0">{
                if m.events[i].FederationID == federationID </span><span class="cov0" title="0">{
                        event := *m.events[i]
                        recentEvents = append(recentEvents, &amp;event)
                        eventCount++
                }</span>
        }

        // Get active alerts
        <span class="cov0" title="0">var activeAlerts []*Alert
        for _, alert := range m.alerts </span><span class="cov0" title="0">{
                if alert.FederationID == federationID &amp;&amp; alert.ResolvedAt == nil </span><span class="cov0" title="0">{
                        alertCopy := *alert
                        activeAlerts = append(activeAlerts, &amp;alertCopy)
                }</span>
        }

        <span class="cov0" title="0">overview := &amp;SystemOverview{
                FederationID:        federationID,
                Status:              federation.Status,
                TotalCollaborators:  totalCollabs,
                ActiveCollaborators: activeCollabs,
                CurrentRound:        federation.CurrentRound,
                TotalRounds:         federation.TotalRounds,
                Progress:            progress,
                RecentEvents:        recentEvents,
                Alerts:              activeAlerts,
        }

        return overview, nil</span>
}

// Events and alerts implementation
func (m *MemoryStorage) RecordEvent(ctx context.Context, event *MonitoringEvent) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if event.ID == "" </span><span class="cov0" title="0">{
                event.ID = uuid.New().String()
        }</span>

        <span class="cov0" title="0">m.events = append(m.events, event)
        m.notifySubscribers(event)

        // Keep only recent events to prevent memory overflow
        maxEvents := 10000
        if len(m.events) &gt; maxEvents </span><span class="cov0" title="0">{
                m.events = m.events[len(m.events)-maxEvents:]
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *MemoryStorage) GetEvents(ctx context.Context, filter *MetricsFilter) ([]*MonitoringEvent, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var results []*MonitoringEvent
        for _, event := range m.events </span><span class="cov0" title="0">{
                if m.matchesEventFilter(event, filter) </span><span class="cov0" title="0">{
                        result := *event
                        results = append(results, &amp;result)
                }</span>
        }

        // Sort by timestamp (newest first)
        <span class="cov0" title="0">sort.Slice(results, func(i, j int) bool </span><span class="cov0" title="0">{
                return results[i].Timestamp.After(results[j].Timestamp)
        }</span>)

        <span class="cov0" title="0">return m.paginateEvents(results, filter), nil</span>
}

func (m *MemoryStorage) GetActiveAlerts(ctx context.Context, federationID string) ([]*Alert, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var alerts []*Alert
        for _, alert := range m.alerts </span><span class="cov0" title="0">{
                if alert.FederationID == federationID &amp;&amp; alert.ResolvedAt == nil </span><span class="cov0" title="0">{
                        result := *alert
                        alerts = append(alerts, &amp;result)
                }</span>
        }

        <span class="cov0" title="0">return alerts, nil</span>
}

// Placeholder implementations for advanced analytics
func (m *MemoryStorage) GetPerformanceInsights(ctx context.Context, federationID string) (*PerformanceInsights, error) <span class="cov0" title="0">{
        // This would contain complex analysis logic
        return &amp;PerformanceInsights{
                FederationID:            federationID,
                OverallPerformance:      85.0,
                TrainingEfficiency:      78.5,
                CommunicationEfficiency: 92.3,
                ResourceUtilization:     67.8,
                BottleneckAnalysis:      []string{"Network latency between collaborators", "Heterogeneous compute capabilities"},
                Recommendations:         []string{"Consider increasing batch size", "Implement adaptive learning rates"},
        }, nil
}</span>

func (m *MemoryStorage) GetConvergenceAnalysis(ctx context.Context, federationID string) (*ConvergenceAnalysis, error) <span class="cov0" title="0">{
        // This would analyze model convergence trends
        return &amp;ConvergenceAnalysis{
                FederationID:      federationID,
                ConvergenceRate:   0.15,
                ParticipationRate: 95.0,
                QualityMetrics:    map[string]float64{"accuracy": 0.87, "f1_score": 0.82},
        }, nil
}</span>

func (m *MemoryStorage) GetEfficiencyMetrics(ctx context.Context, federationID string) (*EfficiencyMetrics, error) <span class="cov0" title="0">{
        // This would calculate various efficiency metrics
        return &amp;EfficiencyMetrics{
                FederationID:            federationID,
                ComputationalEfficiency: 78.5,
                CommunicationEfficiency: 85.2,
                ResourceOptimization:    72.1,
        }, nil
}</span>

// Dashboard management
func (m *MemoryStorage) CreateDashboard(ctx context.Context, dashboard *Dashboard) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if dashboard.ID == "" </span><span class="cov0" title="0">{
                dashboard.ID = uuid.New().String()
        }</span>
        <span class="cov0" title="0">dashboard.CreatedAt = time.Now()
        dashboard.UpdatedAt = time.Now()

        m.dashboards[dashboard.ID] = dashboard
        return nil</span>
}

func (m *MemoryStorage) GetDashboard(ctx context.Context, dashboardID string) (*Dashboard, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        dashboard, exists := m.dashboards[dashboardID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dashboard %s not found", dashboardID)
        }</span>

        <span class="cov0" title="0">result := *dashboard
        return &amp;result, nil</span>
}

func (m *MemoryStorage) ListDashboards(ctx context.Context) ([]*Dashboard, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var dashboards []*Dashboard
        for _, dashboard := range m.dashboards </span><span class="cov0" title="0">{
                result := *dashboard
                dashboards = append(dashboards, &amp;result)
        }</span>

        // Sort by creation time
        <span class="cov0" title="0">sort.Slice(dashboards, func(i, j int) bool </span><span class="cov0" title="0">{
                return dashboards[i].CreatedAt.After(dashboards[j].CreatedAt)
        }</span>)

        <span class="cov0" title="0">return dashboards, nil</span>
}

func (m *MemoryStorage) UpdateDashboard(ctx context.Context, dashboardID string, dashboard *Dashboard) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if _, exists := m.dashboards[dashboardID]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("dashboard %s not found", dashboardID)
        }</span>

        <span class="cov0" title="0">dashboard.ID = dashboardID
        dashboard.UpdatedAt = time.Now()
        m.dashboards[dashboardID] = dashboard

        return nil</span>
}

func (m *MemoryStorage) DeleteDashboard(ctx context.Context, dashboardID string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if _, exists := m.dashboards[dashboardID]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("dashboard %s not found", dashboardID)
        }</span>

        <span class="cov0" title="0">delete(m.dashboards, dashboardID)
        return nil</span>
}

// Real-time subscriptions
func (m *MemoryStorage) SubscribeToEvents(ctx context.Context, federationID string, eventTypes []MetricType) (&lt;-chan *MonitoringEvent, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        subscription := &amp;EventSubscription{
                ID:           uuid.New().String(),
                FederationID: federationID,
                EventTypes:   eventTypes,
                Channel:      make(chan *MonitoringEvent, 100), // Buffered channel
                CreatedAt:    time.Now(),
        }

        m.subscriptions[subscription.ID] = subscription
        return subscription.Channel, nil
}</span>

func (m *MemoryStorage) UnsubscribeFromEvents(ctx context.Context, subscriptionID string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        subscription, exists := m.subscriptions[subscriptionID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("subscription %s not found", subscriptionID)
        }</span>

        <span class="cov0" title="0">close(subscription.Channel)
        delete(m.subscriptions, subscriptionID)
        return nil</span>
}

// Health and status
func (m *MemoryStorage) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        // Simple health check - could be extended with more sophisticated checks
        return nil
}</span>

func (m *MemoryStorage) GetMetricsStats(ctx context.Context) (*MetricsStats, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        activeFederations := 0
        for _, federation := range m.federations </span><span class="cov0" title="0">{
                if federation.Status == StatusRunning </span><span class="cov0" title="0">{
                        activeFederations++
                }</span>
        }

        <span class="cov0" title="0">activeCollaborators := 0
        for _, collaborator := range m.collaborators </span><span class="cov0" title="0">{
                if collaborator.Status == CollabStatusConnected || collaborator.Status == CollabStatusTraining </span><span class="cov0" title="0">{
                        activeCollaborators++
                }</span>
        }

        <span class="cov0" title="0">stats := &amp;MetricsStats{
                TotalFederations:    len(m.federations),
                ActiveFederations:   activeFederations,
                TotalCollaborators:  len(m.collaborators),
                ActiveCollaborators: activeCollaborators,
                TotalRounds:         len(m.rounds),
                TotalUpdates:        len(m.modelUpdates),
                StorageUsed:         0,          // Would calculate actual memory usage
                LastCleanup:         time.Now(), // Would track last cleanup
                UptimeSeconds:       int64(time.Since(m.startTime).Seconds()),
        }

        return stats, nil</span>
}

// Helper methods for filtering and pagination
func (m *MemoryStorage) matchesFederationFilter(federation *FederationMetrics, filter *MetricsFilter) bool <span class="cov0" title="0">{
        if filter == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if filter.FederationID != "" &amp;&amp; federation.ID != filter.FederationID </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if filter.Status != "" &amp;&amp; string(federation.Status) != filter.Status </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if filter.StartTime != nil &amp;&amp; federation.StartTime.Before(*filter.StartTime) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if filter.EndTime != nil &amp;&amp; federation.StartTime.After(*filter.EndTime) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func (m *MemoryStorage) matchesCollaboratorFilter(collaborator *CollaboratorMetrics, filter *MetricsFilter) bool <span class="cov0" title="0">{
        if filter == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if filter.FederationID != "" &amp;&amp; collaborator.FederationID != filter.FederationID </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if filter.CollaboratorID != "" &amp;&amp; collaborator.ID != filter.CollaboratorID </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if filter.Status != "" &amp;&amp; string(collaborator.Status) != filter.Status </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if filter.StartTime != nil &amp;&amp; collaborator.JoinTime.Before(*filter.StartTime) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if filter.EndTime != nil &amp;&amp; collaborator.JoinTime.After(*filter.EndTime) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func (m *MemoryStorage) matchesRoundFilter(round *RoundMetrics, filter *MetricsFilter) bool <span class="cov0" title="0">{
        if filter == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if filter.FederationID != "" &amp;&amp; round.FederationID != filter.FederationID </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if filter.RoundNumber != nil &amp;&amp; round.RoundNumber != *filter.RoundNumber </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if filter.Status != "" &amp;&amp; round.Status != filter.Status </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if filter.StartTime != nil &amp;&amp; round.StartTime.Before(*filter.StartTime) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if filter.EndTime != nil &amp;&amp; round.StartTime.After(*filter.EndTime) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func (m *MemoryStorage) matchesUpdateFilter(update *ModelUpdateMetrics, filter *MetricsFilter) bool <span class="cov0" title="0">{
        if filter == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if filter.FederationID != "" &amp;&amp; update.FederationID != filter.FederationID </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if filter.CollaboratorID != "" &amp;&amp; update.CollaboratorID != filter.CollaboratorID </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if filter.RoundNumber != nil &amp;&amp; update.RoundNumber != *filter.RoundNumber </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if filter.StartTime != nil &amp;&amp; update.Timestamp.Before(*filter.StartTime) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if filter.EndTime != nil &amp;&amp; update.Timestamp.After(*filter.EndTime) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func (m *MemoryStorage) matchesAggregationFilter(aggregation *AggregationMetrics, filter *MetricsFilter) bool <span class="cov0" title="0">{
        if filter == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if filter.FederationID != "" &amp;&amp; aggregation.FederationID != filter.FederationID </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if filter.RoundNumber != nil &amp;&amp; aggregation.RoundNumber != *filter.RoundNumber </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if filter.StartTime != nil &amp;&amp; aggregation.StartTime.Before(*filter.StartTime) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if filter.EndTime != nil &amp;&amp; aggregation.StartTime.After(*filter.EndTime) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

func (m *MemoryStorage) matchesEventFilter(event *MonitoringEvent, filter *MetricsFilter) bool <span class="cov0" title="0">{
        if filter == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if filter.FederationID != "" &amp;&amp; event.FederationID != filter.FederationID </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if filter.MetricType != "" &amp;&amp; event.Type != filter.MetricType </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if filter.StartTime != nil &amp;&amp; event.Timestamp.Before(*filter.StartTime) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if filter.EndTime != nil &amp;&amp; event.Timestamp.After(*filter.EndTime) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// Pagination helpers
func (m *MemoryStorage) paginateFederations(results []*FederationMetrics, filter *MetricsFilter) []*FederationMetrics <span class="cov0" title="0">{
        if filter == nil || filter.Page &lt;= 0 </span><span class="cov0" title="0">{
                return results
        }</span>

        <span class="cov0" title="0">page := filter.Page
        perPage := filter.PerPage
        if perPage &lt;= 0 </span><span class="cov0" title="0">{
                perPage = 20 // default
        }</span>

        <span class="cov0" title="0">start := (page - 1) * perPage
        end := start + perPage

        if start &gt;= len(results) </span><span class="cov0" title="0">{
                return []*FederationMetrics{}
        }</span>

        <span class="cov0" title="0">if end &gt; len(results) </span><span class="cov0" title="0">{
                end = len(results)
        }</span>

        <span class="cov0" title="0">return results[start:end]</span>
}

func (m *MemoryStorage) paginateCollaborators(results []*CollaboratorMetrics, filter *MetricsFilter) []*CollaboratorMetrics <span class="cov0" title="0">{
        if filter == nil || filter.Page &lt;= 0 </span><span class="cov0" title="0">{
                return results
        }</span>

        <span class="cov0" title="0">page := filter.Page
        perPage := filter.PerPage
        if perPage &lt;= 0 </span><span class="cov0" title="0">{
                perPage = 20
        }</span>

        <span class="cov0" title="0">start := (page - 1) * perPage
        end := start + perPage

        if start &gt;= len(results) </span><span class="cov0" title="0">{
                return []*CollaboratorMetrics{}
        }</span>

        <span class="cov0" title="0">if end &gt; len(results) </span><span class="cov0" title="0">{
                end = len(results)
        }</span>

        <span class="cov0" title="0">return results[start:end]</span>
}

func (m *MemoryStorage) paginateRounds(results []*RoundMetrics, filter *MetricsFilter) []*RoundMetrics <span class="cov0" title="0">{
        if filter == nil || filter.Page &lt;= 0 </span><span class="cov0" title="0">{
                return results
        }</span>

        <span class="cov0" title="0">page := filter.Page
        perPage := filter.PerPage
        if perPage &lt;= 0 </span><span class="cov0" title="0">{
                perPage = 20
        }</span>

        <span class="cov0" title="0">start := (page - 1) * perPage
        end := start + perPage

        if start &gt;= len(results) </span><span class="cov0" title="0">{
                return []*RoundMetrics{}
        }</span>

        <span class="cov0" title="0">if end &gt; len(results) </span><span class="cov0" title="0">{
                end = len(results)
        }</span>

        <span class="cov0" title="0">return results[start:end]</span>
}

func (m *MemoryStorage) paginateUpdates(results []*ModelUpdateMetrics, filter *MetricsFilter) []*ModelUpdateMetrics <span class="cov0" title="0">{
        if filter == nil || filter.Page &lt;= 0 </span><span class="cov0" title="0">{
                return results
        }</span>

        <span class="cov0" title="0">page := filter.Page
        perPage := filter.PerPage
        if perPage &lt;= 0 </span><span class="cov0" title="0">{
                perPage = 50
        }</span>

        <span class="cov0" title="0">start := (page - 1) * perPage
        end := start + perPage

        if start &gt;= len(results) </span><span class="cov0" title="0">{
                return []*ModelUpdateMetrics{}
        }</span>

        <span class="cov0" title="0">if end &gt; len(results) </span><span class="cov0" title="0">{
                end = len(results)
        }</span>

        <span class="cov0" title="0">return results[start:end]</span>
}

func (m *MemoryStorage) paginateAggregations(results []*AggregationMetrics, filter *MetricsFilter) []*AggregationMetrics <span class="cov0" title="0">{
        if filter == nil || filter.Page &lt;= 0 </span><span class="cov0" title="0">{
                return results
        }</span>

        <span class="cov0" title="0">page := filter.Page
        perPage := filter.PerPage
        if perPage &lt;= 0 </span><span class="cov0" title="0">{
                perPage = 20
        }</span>

        <span class="cov0" title="0">start := (page - 1) * perPage
        end := start + perPage

        if start &gt;= len(results) </span><span class="cov0" title="0">{
                return []*AggregationMetrics{}
        }</span>

        <span class="cov0" title="0">if end &gt; len(results) </span><span class="cov0" title="0">{
                end = len(results)
        }</span>

        <span class="cov0" title="0">return results[start:end]</span>
}

func (m *MemoryStorage) paginateEvents(results []*MonitoringEvent, filter *MetricsFilter) []*MonitoringEvent <span class="cov0" title="0">{
        if filter == nil || filter.Page &lt;= 0 </span><span class="cov0" title="0">{
                return results
        }</span>

        <span class="cov0" title="0">page := filter.Page
        perPage := filter.PerPage
        if perPage &lt;= 0 </span><span class="cov0" title="0">{
                perPage = 100
        }</span>

        <span class="cov0" title="0">start := (page - 1) * perPage
        end := start + perPage

        if start &gt;= len(results) </span><span class="cov0" title="0">{
                return []*MonitoringEvent{}
        }</span>

        <span class="cov0" title="0">if end &gt; len(results) </span><span class="cov0" title="0">{
                end = len(results)
        }</span>

        <span class="cov0" title="0">return results[start:end]</span>
}

// notifySubscribers sends events to all relevant subscribers
func (m *MemoryStorage) notifySubscribers(event *MonitoringEvent) <span class="cov0" title="0">{
        for _, subscription := range m.subscriptions </span><span class="cov0" title="0">{
                // Check if subscription matches the event
                if subscription.FederationID != "" &amp;&amp; subscription.FederationID != event.FederationID </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if event type matches subscription
                <span class="cov0" title="0">if len(subscription.EventTypes) &gt; 0 </span><span class="cov0" title="0">{
                        matches := false
                        for _, eventType := range subscription.EventTypes </span><span class="cov0" title="0">{
                                if eventType == event.Type </span><span class="cov0" title="0">{
                                        matches = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !matches </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Send event to subscriber (non-blocking)
                <span class="cov0" title="0">select </span>{
                case subscription.Channel &lt;- event:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                        // Channel is full, skip this event to prevent blocking
                }
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package monitoring

import (
        "time"
)

// Storage defines the interface for different storage backends
type Storage interface {
        // Federation operations
        StoreFederationMetrics(federation FederationMetrics) error
        GetFederationMetrics(id string) (*FederationMetrics, error)
        ListFederations(activeOnly bool) ([]FederationMetrics, error)

        // Collaborator operations
        StoreCollaboratorMetrics(collaborator CollaboratorMetrics) error
        GetCollaboratorMetrics(federationID string) ([]CollaboratorMetrics, error)

        // Round operations
        StoreRoundMetrics(round RoundMetrics) error
        GetRoundMetrics(federationID string, limit int) ([]RoundMetrics, error)

        // Resource metrics operations
        StoreResourceMetrics(metrics ResourceMetrics) error

        // Event operations
        StoreEvent(event MonitoringEvent) error
        GetEvents(federationID string, limit int, offset int) ([]MonitoringEvent, error)

        // Cleanup operations
        Cleanup(maxAge time.Duration) error
        Close() error
}

// StorageConfig represents configuration for different storage backends
type StorageConfig struct {
        Backend    string         `yaml:"backend"` // memory, postgres, redis
        Memory     MemoryConfig   `yaml:"memory"`
        PostgreSQL DatabaseConfig `yaml:"postgresql"`
        Redis      RedisConfig    `yaml:"redis"`
}

// MemoryConfig represents configuration for in-memory storage
type MemoryConfig struct {
        MaxEntries int `yaml:"max_entries"`
}

// NewStorage creates a new storage backend based on configuration
func NewStorage(config StorageConfig) (Storage, error) <span class="cov8" title="1">{
        switch config.Backend </span>{
        case "memory":<span class="cov8" title="1">
                return NewMemoryStorageBackend(config.Memory), nil</span>
        case "postgres", "postgresql":<span class="cov0" title="0">
                return NewPostgreSQLStorage(config.PostgreSQL)</span>
        case "redis":<span class="cov0" title="0">
                return NewRedisStorage(config.Redis)</span>
        default:<span class="cov8" title="1">
                // Default to memory storage
                return NewMemoryStorageBackend(config.Memory), nil</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package monitoring

import (
        "sort"
        "sync"
        "time"
)

// MemoryStorageBackend implements Storage interface using in-memory storage
type MemoryStorageBackend struct {
        mu              sync.RWMutex
        federations     map[string]FederationMetrics
        collaborators   map[string][]CollaboratorMetrics // federationID -&gt; collaborators
        rounds          map[string][]RoundMetrics        // federationID -&gt; rounds
        resourceMetrics []ResourceMetrics
        events          []MonitoringEvent
        config          MemoryConfig
}

// NewMemoryStorageBackend creates a new in-memory storage backend
func NewMemoryStorageBackend(config MemoryConfig) *MemoryStorageBackend <span class="cov8" title="1">{
        if config.MaxEntries &lt;= 0 </span><span class="cov8" title="1">{
                config.MaxEntries = 10000 // Default max entries
        }</span>

        <span class="cov8" title="1">return &amp;MemoryStorageBackend{
                federations:   make(map[string]FederationMetrics),
                collaborators: make(map[string][]CollaboratorMetrics),
                rounds:        make(map[string][]RoundMetrics),
                config:        config,
        }</span>
}

// StoreFederationMetrics stores federation metrics in memory
func (m *MemoryStorageBackend) StoreFederationMetrics(federation FederationMetrics) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        federation.LastUpdate = time.Now()
        m.federations[federation.ID] = federation
        return nil
}</span>

// GetFederationMetrics retrieves federation metrics from memory
func (m *MemoryStorageBackend) GetFederationMetrics(id string) (*FederationMetrics, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if federation, exists := m.federations[id]; exists </span><span class="cov8" title="1">{
                return &amp;federation, nil
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

// ListFederations lists all federations with optional filters
func (m *MemoryStorageBackend) ListFederations(activeOnly bool) ([]FederationMetrics, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var federations []FederationMetrics
        for _, federation := range m.federations </span><span class="cov8" title="1">{
                if activeOnly &amp;&amp; federation.Status != "running" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">federations = append(federations, federation)</span>
        }

        // Sort by start time (newest first)
        <span class="cov8" title="1">sort.Slice(federations, func(i, j int) bool </span><span class="cov0" title="0">{
                return federations[i].StartTime.After(federations[j].StartTime)
        }</span>)

        <span class="cov8" title="1">return federations, nil</span>
}

// StoreCollaboratorMetrics stores collaborator metrics in memory
func (m *MemoryStorageBackend) StoreCollaboratorMetrics(collaborator CollaboratorMetrics) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        collaborators := m.collaborators[collaborator.FederationID]

        // Find existing collaborator or add new one
        found := false
        for i, existing := range collaborators </span><span class="cov0" title="0">{
                if existing.ID == collaborator.ID </span><span class="cov0" title="0">{
                        collaborators[i] = collaborator
                        found = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                collaborators = append(collaborators, collaborator)
        }</span>

        <span class="cov8" title="1">m.collaborators[collaborator.FederationID] = collaborators
        return nil</span>
}

// GetCollaboratorMetrics retrieves collaborator metrics from memory
func (m *MemoryStorageBackend) GetCollaboratorMetrics(federationID string) ([]CollaboratorMetrics, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if collaborators, exists := m.collaborators[federationID]; exists </span><span class="cov8" title="1">{
                // Create a copy to avoid race conditions
                result := make([]CollaboratorMetrics, len(collaborators))
                copy(result, collaborators)
                return result, nil
        }</span>

        <span class="cov0" title="0">return []CollaboratorMetrics{}, nil</span>
}

// StoreRoundMetrics stores round metrics in memory
func (m *MemoryStorageBackend) StoreRoundMetrics(round RoundMetrics) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        rounds := m.rounds[round.FederationID]

        // Find existing round or add new one
        found := false
        for i, existing := range rounds </span><span class="cov0" title="0">{
                if existing.ID == round.ID </span><span class="cov0" title="0">{
                        rounds[i] = round
                        found = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                rounds = append(rounds, round)
        }</span>

        // Sort by round number (descending)
        <span class="cov8" title="1">sort.Slice(rounds, func(i, j int) bool </span><span class="cov0" title="0">{
                return rounds[i].RoundNumber &gt; rounds[j].RoundNumber
        }</span>)

        <span class="cov8" title="1">m.rounds[round.FederationID] = rounds
        return nil</span>
}

// GetRoundMetrics retrieves round metrics from memory
func (m *MemoryStorageBackend) GetRoundMetrics(federationID string, limit int) ([]RoundMetrics, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if rounds, exists := m.rounds[federationID]; exists </span><span class="cov8" title="1">{
                if limit &gt; 0 &amp;&amp; len(rounds) &gt; limit </span><span class="cov0" title="0">{
                        result := make([]RoundMetrics, limit)
                        copy(result, rounds[:limit])
                        return result, nil
                }</span>

                // Create a copy to avoid race conditions
                <span class="cov8" title="1">result := make([]RoundMetrics, len(rounds))
                copy(result, rounds)
                return result, nil</span>
        }

        <span class="cov0" title="0">return []RoundMetrics{}, nil</span>
}

// StoreResourceMetrics stores resource metrics in memory
func (m *MemoryStorageBackend) StoreResourceMetrics(metrics ResourceMetrics) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.resourceMetrics = append(m.resourceMetrics, metrics)

        // Cleanup old entries if we exceed max entries
        if len(m.resourceMetrics) &gt; m.config.MaxEntries </span><span class="cov0" title="0">{
                // Keep only the most recent entries
                keep := m.config.MaxEntries / 2
                m.resourceMetrics = m.resourceMetrics[len(m.resourceMetrics)-keep:]
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// StoreEvent stores monitoring events in memory
func (m *MemoryStorageBackend) StoreEvent(event MonitoringEvent) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.events = append(m.events, event)

        // Cleanup old entries if we exceed max entries
        if len(m.events) &gt; m.config.MaxEntries </span><span class="cov0" title="0">{
                // Keep only the most recent entries
                keep := m.config.MaxEntries / 2
                m.events = m.events[len(m.events)-keep:]
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetEvents retrieves monitoring events from memory
func (m *MemoryStorageBackend) GetEvents(federationID string, limit int, offset int) ([]MonitoringEvent, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var filteredEvents []MonitoringEvent

        // Filter by federation ID if specified
        for i := len(m.events) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{ // Reverse order (newest first)
                event := m.events[i]
                if federationID == "" || event.FederationID == federationID </span><span class="cov8" title="1">{
                        filteredEvents = append(filteredEvents, event)
                }</span>
        }

        // Apply offset and limit
        <span class="cov8" title="1">start := offset
        if start &gt; len(filteredEvents) </span><span class="cov0" title="0">{
                return []MonitoringEvent{}, nil
        }</span>

        <span class="cov8" title="1">end := start + limit
        if limit &lt;= 0 || end &gt; len(filteredEvents) </span><span class="cov8" title="1">{
                end = len(filteredEvents)
        }</span>

        <span class="cov8" title="1">result := make([]MonitoringEvent, end-start)
        copy(result, filteredEvents[start:end])
        return result, nil</span>
}

// Cleanup removes old data from memory
func (m *MemoryStorageBackend) Cleanup(maxAge time.Duration) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        cutoff := time.Now().Add(-maxAge)

        // Clean up resource metrics
        var newResourceMetrics []ResourceMetrics
        for _, metrics := range m.resourceMetrics </span><span class="cov8" title="1">{
                if metrics.Timestamp.After(cutoff) </span><span class="cov8" title="1">{
                        newResourceMetrics = append(newResourceMetrics, metrics)
                }</span>
        }
        <span class="cov8" title="1">m.resourceMetrics = newResourceMetrics

        // Clean up events
        var newEvents []MonitoringEvent
        for _, event := range m.events </span><span class="cov8" title="1">{
                if event.Timestamp.After(cutoff) </span><span class="cov8" title="1">{
                        newEvents = append(newEvents, event)
                }</span>
        }
        <span class="cov8" title="1">m.events = newEvents

        return nil</span>
}

// Close closes the memory storage (no-op for memory backend)
func (m *MemoryStorageBackend) Close() error <span class="cov8" title="1">{
        return nil
}</span>

// GetStats returns memory storage statistics
func (m *MemoryStorageBackend) GetStats() map[string]interface{} <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        return map[string]interface{}{
                "storage_type":        "memory",
                "federations_count":   len(m.federations),
                "total_collaborators": m.getTotalCollaborators(),
                "total_rounds":        m.getTotalRounds(),
                "resource_metrics":    len(m.resourceMetrics),
                "events_count":        len(m.events),
                "max_entries":         m.config.MaxEntries,
        }
}</span>

func (m *MemoryStorageBackend) getTotalCollaborators() int <span class="cov0" title="0">{
        total := 0
        for _, collaborators := range m.collaborators </span><span class="cov0" title="0">{
                total += len(collaborators)
        }</span>
        <span class="cov0" title="0">return total</span>
}

func (m *MemoryStorageBackend) getTotalRounds() int <span class="cov0" title="0">{
        total := 0
        for _, rounds := range m.rounds </span><span class="cov0" title="0">{
                total += len(rounds)
        }</span>
        <span class="cov0" title="0">return total</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package monitoring

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        _ "github.com/lib/pq"
)

// PostgreSQLStorage implements Storage interface using PostgreSQL
type PostgreSQLStorage struct {
        db     *sql.DB
        config DatabaseConfig
}

// DatabaseConfig represents database connection configuration
type DatabaseConfig struct {
        Host     string `yaml:"host"`
        Port     int    `yaml:"port"`
        User     string `yaml:"user"`
        Password string `yaml:"password"`
        Database string `yaml:"database"`
        SSLMode  string `yaml:"ssl_mode"`
        MaxConns int    `yaml:"max_connections"`
}

// NewPostgreSQLStorage creates a new PostgreSQL storage backend
func NewPostgreSQLStorage(config DatabaseConfig) (*PostgreSQLStorage, error) <span class="cov0" title="0">{
        dsn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                config.Host, config.Port, config.User, config.Password, config.Database, config.SSLMode)

        db, err := sql.Open("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database connection: %w", err)
        }</span>

        <span class="cov0" title="0">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        // Set connection pool settings
        <span class="cov0" title="0">if config.MaxConns &gt; 0 </span><span class="cov0" title="0">{
                db.SetMaxOpenConns(config.MaxConns)
                db.SetMaxIdleConns(config.MaxConns / 2)
        }</span>
        <span class="cov0" title="0">db.SetConnMaxLifetime(time.Hour)

        storage := &amp;PostgreSQLStorage{
                db:     db,
                config: config,
        }

        // Initialize database schema
        if err := storage.initSchema(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize database schema: %w", err)
        }</span>

        <span class="cov0" title="0">return storage, nil</span>
}

// initSchema creates the necessary database tables
func (p *PostgreSQLStorage) initSchema() error <span class="cov0" title="0">{
        schemas := []string{
                `CREATE TABLE IF NOT EXISTS federations (
                        id VARCHAR(255) PRIMARY KEY,
                        name VARCHAR(255) NOT NULL,
                        status VARCHAR(50) NOT NULL,
                        mode VARCHAR(20) NOT NULL,
                        algorithm VARCHAR(50) NOT NULL,
                        current_round INTEGER NOT NULL DEFAULT 0,
                        total_rounds INTEGER NOT NULL DEFAULT 0,
                        active_collaborators INTEGER NOT NULL DEFAULT 0,
                        total_collaborators INTEGER NOT NULL DEFAULT 0,
                        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
                        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
                )`,

                `CREATE TABLE IF NOT EXISTS collaborators (
                        id VARCHAR(255) PRIMARY KEY,
                        federation_id VARCHAR(255) NOT NULL,
                        name VARCHAR(255) NOT NULL,
                        status VARCHAR(50) NOT NULL,
                        address VARCHAR(255),
                        last_seen TIMESTAMP WITH TIME ZONE,
                        updates_submitted INTEGER NOT NULL DEFAULT 0,
                        errors INTEGER NOT NULL DEFAULT 0,
                        avg_training_time REAL DEFAULT 0,
                        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
                        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
                        FOREIGN KEY (federation_id) REFERENCES federations(id) ON DELETE CASCADE
                )`,

                `CREATE TABLE IF NOT EXISTS rounds (
                        id VARCHAR(255) PRIMARY KEY,
                        federation_id VARCHAR(255) NOT NULL,
                        round_number INTEGER NOT NULL,
                        algorithm VARCHAR(50) NOT NULL,
                        participants INTEGER NOT NULL DEFAULT 0,
                        start_time TIMESTAMP WITH TIME ZONE,
                        end_time TIMESTAMP WITH TIME ZONE,
                        duration_seconds REAL DEFAULT 0,
                        updates_received INTEGER NOT NULL DEFAULT 0,
                        accuracy REAL DEFAULT 0,
                        loss REAL DEFAULT 0,
                        convergence_rate REAL DEFAULT 0,
                        communication_cost REAL DEFAULT 0,
                        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
                        FOREIGN KEY (federation_id) REFERENCES federations(id) ON DELETE CASCADE
                )`,

                `CREATE TABLE IF NOT EXISTS model_updates (
                        id VARCHAR(255) PRIMARY KEY,
                        federation_id VARCHAR(255) NOT NULL,
                        collaborator_id VARCHAR(255) NOT NULL,
                        round_number INTEGER NOT NULL,
                        update_size INTEGER NOT NULL DEFAULT 0,
                        processing_time REAL DEFAULT 0,
                        staleness INTEGER DEFAULT 0,
                        weight REAL DEFAULT 1.0,
                        accuracy REAL DEFAULT 0,
                        loss REAL DEFAULT 0,
                        timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
                        FOREIGN KEY (federation_id) REFERENCES federations(id) ON DELETE CASCADE,
                        FOREIGN KEY (collaborator_id) REFERENCES collaborators(id) ON DELETE CASCADE
                )`,

                `CREATE TABLE IF NOT EXISTS resource_metrics (
                        id SERIAL PRIMARY KEY,
                        source_id VARCHAR(255) NOT NULL,
                        source_type VARCHAR(50) NOT NULL,
                        cpu_usage REAL DEFAULT 0,
                        memory_usage REAL DEFAULT 0,
                        disk_usage REAL DEFAULT 0,
                        network_in REAL DEFAULT 0,
                        network_out REAL DEFAULT 0,
                        timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
                )`,

                `CREATE TABLE IF NOT EXISTS events (
                        id SERIAL PRIMARY KEY,
                        federation_id VARCHAR(255),
                        event_type VARCHAR(100) NOT NULL,
                        description TEXT,
                        severity VARCHAR(20) DEFAULT 'info',
                        metadata JSONB,
                        timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
                        FOREIGN KEY (federation_id) REFERENCES federations(id) ON DELETE CASCADE
                )`,

                // Indexes for better performance
                `CREATE INDEX IF NOT EXISTS idx_collaborators_federation ON collaborators(federation_id)`,
                `CREATE INDEX IF NOT EXISTS idx_rounds_federation ON rounds(federation_id)`,
                `CREATE INDEX IF NOT EXISTS idx_model_updates_federation ON model_updates(federation_id)`,
                `CREATE INDEX IF NOT EXISTS idx_model_updates_collaborator ON model_updates(collaborator_id)`,
                `CREATE INDEX IF NOT EXISTS idx_resource_metrics_source ON resource_metrics(source_id, timestamp)`,
                `CREATE INDEX IF NOT EXISTS idx_events_federation ON events(federation_id, timestamp)`,
                `CREATE INDEX IF NOT EXISTS idx_events_timestamp ON events(timestamp)`,
        }

        for _, schema := range schemas </span><span class="cov0" title="0">{
                if _, err := p.db.Exec(schema); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute schema: %s, error: %w", schema, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// StoreFederationMetrics stores federation metrics in PostgreSQL
func (p *PostgreSQLStorage) StoreFederationMetrics(federation FederationMetrics) error <span class="cov0" title="0">{
        query := `
                INSERT INTO federations (id, name, status, mode, algorithm, current_round, total_rounds, active_collaborators, total_collaborators, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW())
                ON CONFLICT (id) DO UPDATE SET
                        name = EXCLUDED.name,
                        status = EXCLUDED.status,
                        mode = EXCLUDED.mode,
                        algorithm = EXCLUDED.algorithm,
                        current_round = EXCLUDED.current_round,
                        total_rounds = EXCLUDED.total_rounds,
                        active_collaborators = EXCLUDED.active_collaborators,
                        total_collaborators = EXCLUDED.total_collaborators,
                        updated_at = NOW()
        `

        _, err := p.db.Exec(query, federation.ID, federation.Name, federation.Status, federation.Mode,
                federation.Algorithm, federation.CurrentRound, federation.TotalRounds,
                federation.ActiveCollabs, federation.TotalCollabs)

        return err
}</span>

// GetFederationMetrics retrieves federation metrics from PostgreSQL
func (p *PostgreSQLStorage) GetFederationMetrics(id string) (*FederationMetrics, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, status, mode, algorithm, current_round, total_rounds, 
                       active_collaborators, total_collaborators, created_at, updated_at
                FROM federations WHERE id = $1
        `

        var federation FederationMetrics
        var createdAt, updatedAt time.Time

        err := p.db.QueryRow(query, id).Scan(
                &amp;federation.ID, &amp;federation.Name, &amp;federation.Status, &amp;federation.Mode,
                &amp;federation.Algorithm, &amp;federation.CurrentRound, &amp;federation.TotalRounds,
                &amp;federation.ActiveCollabs, &amp;federation.TotalCollabs,
                &amp;createdAt, &amp;updatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">federation.StartTime = createdAt
        federation.LastUpdate = updatedAt

        return &amp;federation, nil</span>
}

// ListFederations lists all federations with optional filters
func (p *PostgreSQLStorage) ListFederations(activeOnly bool) ([]FederationMetrics, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, status, mode, algorithm, current_round, total_rounds,
                       active_collaborators, total_collaborators, created_at, updated_at
                FROM federations
        `

        if activeOnly </span><span class="cov0" title="0">{
                query += " WHERE status = 'running'"
        }</span>

        <span class="cov0" title="0">query += " ORDER BY created_at DESC"

        rows, err := p.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var federations []FederationMetrics
        for rows.Next() </span><span class="cov0" title="0">{
                var federation FederationMetrics
                var createdAt, updatedAt time.Time

                err := rows.Scan(
                        &amp;federation.ID, &amp;federation.Name, &amp;federation.Status, &amp;federation.Mode,
                        &amp;federation.Algorithm, &amp;federation.CurrentRound, &amp;federation.TotalRounds,
                        &amp;federation.ActiveCollabs, &amp;federation.TotalCollabs,
                        &amp;createdAt, &amp;updatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">federation.StartTime = createdAt
                federation.LastUpdate = updatedAt
                federations = append(federations, federation)</span>
        }

        <span class="cov0" title="0">return federations, rows.Err()</span>
}

// StoreCollaboratorMetrics stores collaborator metrics in PostgreSQL
func (p *PostgreSQLStorage) StoreCollaboratorMetrics(collaborator CollaboratorMetrics) error <span class="cov0" title="0">{
        query := `
                INSERT INTO collaborators (id, federation_id, name, status, address, last_seen, updates_submitted, errors, avg_training_time, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW())
                ON CONFLICT (id) DO UPDATE SET
                        federation_id = EXCLUDED.federation_id,
                        name = EXCLUDED.name,
                        status = EXCLUDED.status,
                        address = EXCLUDED.address,
                        last_seen = EXCLUDED.last_seen,
                        updates_submitted = EXCLUDED.updates_submitted,
                        errors = EXCLUDED.errors,
                        avg_training_time = EXCLUDED.avg_training_time,
                        updated_at = NOW()
        `

        // Extract training time as float64 seconds
        trainingTimeSeconds := collaborator.TrainingTime.Seconds()

        _, err := p.db.Exec(query, collaborator.ID, collaborator.FederationID, collaborator.ID, // Use ID as name for now
                collaborator.Status, collaborator.Address, collaborator.LastSeen,
                collaborator.UpdatesSubmitted, collaborator.ErrorCount, trainingTimeSeconds)

        return err
}</span>

// GetCollaboratorMetrics retrieves collaborator metrics from PostgreSQL
func (p *PostgreSQLStorage) GetCollaboratorMetrics(federationID string) ([]CollaboratorMetrics, error) <span class="cov0" title="0">{
        query := `
                SELECT id, federation_id, name, status, address, last_seen, updates_submitted, errors, avg_training_time, created_at, updated_at
                FROM collaborators WHERE federation_id = $1 ORDER BY created_at
        `

        rows, err := p.db.Query(query, federationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var collaborators []CollaboratorMetrics
        for rows.Next() </span><span class="cov0" title="0">{
                var collaborator CollaboratorMetrics
                var lastSeen sql.NullTime
                var createdAt, updatedAt time.Time
                var name string
                var errors int
                var avgTrainingTimeSeconds float64

                err := rows.Scan(
                        &amp;collaborator.ID, &amp;collaborator.FederationID, &amp;name,
                        &amp;collaborator.Status, &amp;collaborator.Address, &amp;lastSeen,
                        &amp;collaborator.UpdatesSubmitted, &amp;errors, &amp;avgTrainingTimeSeconds,
                        &amp;createdAt, &amp;updatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if lastSeen.Valid </span><span class="cov0" title="0">{
                        collaborator.LastSeen = lastSeen.Time
                }</span>
                <span class="cov0" title="0">collaborator.JoinTime = createdAt
                collaborator.ErrorCount = errors
                collaborator.TrainingTime = time.Duration(avgTrainingTimeSeconds * float64(time.Second))

                collaborators = append(collaborators, collaborator)</span>
        }

        <span class="cov0" title="0">return collaborators, rows.Err()</span>
}

// StoreRoundMetrics stores round metrics in PostgreSQL
func (p *PostgreSQLStorage) StoreRoundMetrics(round RoundMetrics) error <span class="cov0" title="0">{
        query := `
                INSERT INTO rounds (id, federation_id, round_number, algorithm, participants, start_time, end_time, duration_seconds, updates_received, accuracy, loss, convergence_rate, communication_cost)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
                ON CONFLICT (id) DO UPDATE SET
                        federation_id = EXCLUDED.federation_id,
                        round_number = EXCLUDED.round_number,
                        algorithm = EXCLUDED.algorithm,
                        participants = EXCLUDED.participants,
                        start_time = EXCLUDED.start_time,
                        end_time = EXCLUDED.end_time,
                        duration_seconds = EXCLUDED.duration_seconds,
                        updates_received = EXCLUDED.updates_received,
                        accuracy = EXCLUDED.accuracy,
                        loss = EXCLUDED.loss,
                        convergence_rate = EXCLUDED.convergence_rate,
                        communication_cost = EXCLUDED.communication_cost
        `

        // Handle optional fields
        var accuracy, loss, convergenceRate interface{}
        if round.ModelAccuracy != nil </span><span class="cov0" title="0">{
                accuracy = *round.ModelAccuracy
        }</span>
        <span class="cov0" title="0">if round.ModelLoss != nil </span><span class="cov0" title="0">{
                loss = *round.ModelLoss
        }</span>
        <span class="cov0" title="0">if round.ConvergenceRate != nil </span><span class="cov0" title="0">{
                convergenceRate = *round.ConvergenceRate
        }</span>

        <span class="cov0" title="0">_, err := p.db.Exec(query, round.ID, round.FederationID, round.RoundNumber, round.Algorithm,
                round.ParticipantCount, round.StartTime, round.EndTime, round.Duration.Seconds(),
                round.UpdatesReceived, accuracy, loss, convergenceRate, 0.0) // communication_cost placeholder

        return err</span>
}

// GetRoundMetrics retrieves round metrics from PostgreSQL
func (p *PostgreSQLStorage) GetRoundMetrics(federationID string, limit int) ([]RoundMetrics, error) <span class="cov0" title="0">{
        query := `
                SELECT id, federation_id, round_number, algorithm, participants, start_time, end_time, duration_seconds, updates_received, accuracy, loss, convergence_rate, communication_cost, created_at
                FROM rounds WHERE federation_id = $1 ORDER BY round_number DESC
        `

        if limit &gt; 0 </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" LIMIT %d", limit)
        }</span>

        <span class="cov0" title="0">rows, err := p.db.Query(query, federationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var rounds []RoundMetrics
        for rows.Next() </span><span class="cov0" title="0">{
                var round RoundMetrics
                var startTime, endTime sql.NullTime
                var durationSeconds float64
                var createdAt time.Time
                var accuracy, loss, convergenceRate sql.NullFloat64
                var communicationCost float64

                err := rows.Scan(
                        &amp;round.ID, &amp;round.FederationID, &amp;round.RoundNumber, &amp;round.Algorithm,
                        &amp;round.ParticipantCount, &amp;startTime, &amp;endTime, &amp;durationSeconds,
                        &amp;round.UpdatesReceived, &amp;accuracy, &amp;loss,
                        &amp;convergenceRate, &amp;communicationCost, &amp;createdAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if startTime.Valid </span><span class="cov0" title="0">{
                        round.StartTime = startTime.Time
                }</span>
                <span class="cov0" title="0">if endTime.Valid </span><span class="cov0" title="0">{
                        round.EndTime = &amp;endTime.Time
                }</span>
                <span class="cov0" title="0">round.Duration = time.Duration(durationSeconds * float64(time.Second))

                // Handle optional fields
                if accuracy.Valid </span><span class="cov0" title="0">{
                        round.ModelAccuracy = &amp;accuracy.Float64
                }</span>
                <span class="cov0" title="0">if loss.Valid </span><span class="cov0" title="0">{
                        round.ModelLoss = &amp;loss.Float64
                }</span>
                <span class="cov0" title="0">if convergenceRate.Valid </span><span class="cov0" title="0">{
                        round.ConvergenceRate = &amp;convergenceRate.Float64
                }</span>

                <span class="cov0" title="0">rounds = append(rounds, round)</span>
        }

        <span class="cov0" title="0">return rounds, rows.Err()</span>
}

// StoreResourceMetrics stores resource metrics in PostgreSQL
func (p *PostgreSQLStorage) StoreResourceMetrics(metrics ResourceMetrics) error <span class="cov0" title="0">{
        query := `
                INSERT INTO resource_metrics (source_id, source_type, cpu_usage, memory_usage, disk_usage, network_in, network_out, timestamp)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        `

        // Use placeholder values for source_id and source_type since they're not in ResourceMetrics
        sourceID := "unknown"
        sourceType := "system"

        _, err := p.db.Exec(query, sourceID, sourceType, metrics.CPUUsage,
                metrics.MemoryUsage, metrics.DiskUsage, metrics.NetworkRxRate, metrics.NetworkTxRate, metrics.Timestamp)

        return err
}</span>

// StoreEvent stores monitoring events in PostgreSQL
func (p *PostgreSQLStorage) StoreEvent(event MonitoringEvent) error <span class="cov0" title="0">{
        metadataJSON, err := json.Marshal(event.Data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal event data: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO events (federation_id, event_type, description, severity, metadata, timestamp)
                VALUES ($1, $2, $3, $4, $5, $6)
        `

        _, err = p.db.Exec(query, event.FederationID, event.Type, event.Message,
                event.Level, metadataJSON, event.Timestamp)

        return err</span>
}

// GetEvents retrieves monitoring events from PostgreSQL
func (p *PostgreSQLStorage) GetEvents(federationID string, limit int, offset int) ([]MonitoringEvent, error) <span class="cov0" title="0">{
        query := `
                SELECT federation_id, event_type, description, severity, metadata, timestamp
                FROM events
        `

        args := []interface{}{}
        argCount := 0

        if federationID != "" </span><span class="cov0" title="0">{
                argCount++
                query += fmt.Sprintf(" WHERE federation_id = $%d", argCount)
                args = append(args, federationID)
        }</span>

        <span class="cov0" title="0">query += " ORDER BY timestamp DESC"

        if limit &gt; 0 </span><span class="cov0" title="0">{
                argCount++
                query += fmt.Sprintf(" LIMIT $%d", argCount)
                args = append(args, limit)
        }</span>

        <span class="cov0" title="0">if offset &gt; 0 </span><span class="cov0" title="0">{
                argCount++
                query += fmt.Sprintf(" OFFSET $%d", argCount)
                args = append(args, offset)
        }</span>

        <span class="cov0" title="0">rows, err := p.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var events []MonitoringEvent
        for rows.Next() </span><span class="cov0" title="0">{
                var event MonitoringEvent
                var metadataJSON []byte
                var federationID sql.NullString

                err := rows.Scan(
                        &amp;federationID, &amp;event.Type, &amp;event.Message,
                        &amp;event.Level, &amp;metadataJSON, &amp;event.Timestamp,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if federationID.Valid </span><span class="cov0" title="0">{
                        event.FederationID = federationID.String
                }</span>

                <span class="cov0" title="0">if len(metadataJSON) &gt; 0 </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(metadataJSON, &amp;event.Data); err != nil </span><span class="cov0" title="0">{
                                // Log error but don't fail the query
                                event.Data = map[string]interface{}{"error": "failed to unmarshal metadata"}
                        }</span>
                }

                <span class="cov0" title="0">events = append(events, event)</span>
        }

        <span class="cov0" title="0">return events, rows.Err()</span>
}

// Close closes the PostgreSQL database connection
func (p *PostgreSQLStorage) Close() error <span class="cov0" title="0">{
        return p.db.Close()
}</span>

// Cleanup removes old data from the database
func (p *PostgreSQLStorage) Cleanup(maxAge time.Duration) error <span class="cov0" title="0">{
        cutoff := time.Now().Add(-maxAge)

        queries := []string{
                "DELETE FROM resource_metrics WHERE timestamp &lt; $1",
                "DELETE FROM events WHERE timestamp &lt; $1",
                "DELETE FROM model_updates WHERE timestamp &lt; $1",
        }

        for _, query := range queries </span><span class="cov0" title="0">{
                if _, err := p.db.Exec(query, cutoff); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cleanup failed for query %s: %w", query, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package monitoring

import (
        "context"
        "encoding/json"
        "fmt"
        "strconv"
        "time"

        "github.com/redis/go-redis/v9"
)

// RedisStorage implements Storage interface using Redis
type RedisStorage struct {
        client *redis.Client
        config RedisConfig
        ctx    context.Context
}

// RedisConfig represents Redis connection configuration
type RedisConfig struct {
        Address  string `yaml:"address"`
        Password string `yaml:"password"`
        Database int    `yaml:"database"`
        PoolSize int    `yaml:"pool_size"`
        TTL      string `yaml:"ttl"` // Default TTL for keys
}

// NewRedisStorage creates a new Redis storage backend
func NewRedisStorage(config RedisConfig) (*RedisStorage, error) <span class="cov0" title="0">{
        opts := &amp;redis.Options{
                Addr:     config.Address,
                Password: config.Password,
                DB:       config.Database,
        }

        if config.PoolSize &gt; 0 </span><span class="cov0" title="0">{
                opts.PoolSize = config.PoolSize
        }</span>

        <span class="cov0" title="0">client := redis.NewClient(opts)
        ctx := context.Background()

        // Test connection
        if err := client.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to Redis: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;RedisStorage{
                client: client,
                config: config,
                ctx:    ctx,
        }, nil</span>
}

// getDefaultTTL returns the default TTL for Redis keys
func (r *RedisStorage) getDefaultTTL() time.Duration <span class="cov0" title="0">{
        if r.config.TTL == "" </span><span class="cov0" title="0">{
                return 24 * time.Hour // Default 24 hours
        }</span>

        <span class="cov0" title="0">duration, err := time.ParseDuration(r.config.TTL)
        if err != nil </span><span class="cov0" title="0">{
                return 24 * time.Hour // Fallback to default
        }</span>

        <span class="cov0" title="0">return duration</span>
}

// StoreFederationMetrics stores federation metrics in Redis
func (r *RedisStorage) StoreFederationMetrics(federation FederationMetrics) error <span class="cov0" title="0">{
        key := fmt.Sprintf("federation:%s", federation.ID)

        // Update last updated time
        federation.LastUpdate = time.Now()

        data, err := json.Marshal(federation)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal federation metrics: %w", err)
        }</span>

        <span class="cov0" title="0">if err := r.client.Set(r.ctx, key, data, r.getDefaultTTL()).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store federation metrics: %w", err)
        }</span>

        // Add to federations list
        <span class="cov0" title="0">listKey := "federations:list"
        if err := r.client.SAdd(r.ctx, listKey, federation.ID).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add federation to list: %w", err)
        }</span>

        // Set TTL for the list as well
        <span class="cov0" title="0">r.client.Expire(r.ctx, listKey, r.getDefaultTTL())

        return nil</span>
}

// GetFederationMetrics retrieves federation metrics from Redis
func (r *RedisStorage) GetFederationMetrics(id string) (*FederationMetrics, error) <span class="cov0" title="0">{
        key := fmt.Sprintf("federation:%s", id)

        data, err := r.client.Get(r.ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                if err == redis.Nil </span><span class="cov0" title="0">{
                        return nil, nil // Not found
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get federation metrics: %w", err)</span>
        }

        <span class="cov0" title="0">var federation FederationMetrics
        if err := json.Unmarshal([]byte(data), &amp;federation); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal federation metrics: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;federation, nil</span>
}

// ListFederations lists all federations with optional filters
func (r *RedisStorage) ListFederations(activeOnly bool) ([]FederationMetrics, error) <span class="cov0" title="0">{
        listKey := "federations:list"

        federationIDs, err := r.client.SMembers(r.ctx, listKey).Result()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get federation list: %w", err)
        }</span>

        <span class="cov0" title="0">var federations []FederationMetrics
        for _, id := range federationIDs </span><span class="cov0" title="0">{
                federation, err := r.GetFederationMetrics(id)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip failed federations
                }
                <span class="cov0" title="0">if federation == nil </span><span class="cov0" title="0">{
                        continue</span> // Skip not found federations
                }

                // Apply active filter
                <span class="cov0" title="0">if activeOnly &amp;&amp; federation.Status != "running" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">federations = append(federations, *federation)</span>
        }

        <span class="cov0" title="0">return federations, nil</span>
}

// StoreCollaboratorMetrics stores collaborator metrics in Redis
func (r *RedisStorage) StoreCollaboratorMetrics(collaborator CollaboratorMetrics) error <span class="cov0" title="0">{
        key := fmt.Sprintf("collaborator:%s", collaborator.ID)

        data, err := json.Marshal(collaborator)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal collaborator metrics: %w", err)
        }</span>

        <span class="cov0" title="0">if err := r.client.Set(r.ctx, key, data, r.getDefaultTTL()).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store collaborator metrics: %w", err)
        }</span>

        // Add to federation's collaborators list
        <span class="cov0" title="0">federationKey := fmt.Sprintf("federation:%s:collaborators", collaborator.FederationID)
        if err := r.client.SAdd(r.ctx, federationKey, collaborator.ID).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add collaborator to federation list: %w", err)
        }</span>

        // Set TTL for the federation list
        <span class="cov0" title="0">r.client.Expire(r.ctx, federationKey, r.getDefaultTTL())

        return nil</span>
}

// GetCollaboratorMetrics retrieves collaborator metrics from Redis
func (r *RedisStorage) GetCollaboratorMetrics(federationID string) ([]CollaboratorMetrics, error) <span class="cov0" title="0">{
        federationKey := fmt.Sprintf("federation:%s:collaborators", federationID)

        collaboratorIDs, err := r.client.SMembers(r.ctx, federationKey).Result()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get collaborator list: %w", err)
        }</span>

        <span class="cov0" title="0">var collaborators []CollaboratorMetrics
        for _, id := range collaboratorIDs </span><span class="cov0" title="0">{
                key := fmt.Sprintf("collaborator:%s", id)

                data, err := r.client.Get(r.ctx, key).Result()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip failed collaborators
                }

                <span class="cov0" title="0">var collaborator CollaboratorMetrics
                if err := json.Unmarshal([]byte(data), &amp;collaborator); err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid data
                }

                <span class="cov0" title="0">collaborators = append(collaborators, collaborator)</span>
        }

        <span class="cov0" title="0">return collaborators, nil</span>
}

// StoreRoundMetrics stores round metrics in Redis
func (r *RedisStorage) StoreRoundMetrics(round RoundMetrics) error <span class="cov0" title="0">{
        key := fmt.Sprintf("round:%s", round.ID)

        data, err := json.Marshal(round)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal round metrics: %w", err)
        }</span>

        <span class="cov0" title="0">if err := r.client.Set(r.ctx, key, data, r.getDefaultTTL()).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store round metrics: %w", err)
        }</span>

        // Add to federation's rounds sorted set (by round number)
        <span class="cov0" title="0">federationKey := fmt.Sprintf("federation:%s:rounds", round.FederationID)
        score := float64(round.RoundNumber)

        if err := r.client.ZAdd(r.ctx, federationKey, redis.Z{
                Score:  score,
                Member: round.ID,
        }).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add round to federation rounds: %w", err)
        }</span>

        // Set TTL for the federation rounds list
        <span class="cov0" title="0">r.client.Expire(r.ctx, federationKey, r.getDefaultTTL())

        return nil</span>
}

// GetRoundMetrics retrieves round metrics from Redis
func (r *RedisStorage) GetRoundMetrics(federationID string, limit int) ([]RoundMetrics, error) <span class="cov0" title="0">{
        federationKey := fmt.Sprintf("federation:%s:rounds", federationID)

        // Get round IDs from sorted set (highest round numbers first)
        var roundIDs []string
        var err error

        if limit &gt; 0 </span><span class="cov0" title="0">{
                roundIDs, err = r.client.ZRevRange(r.ctx, federationKey, 0, int64(limit-1)).Result()
        }</span> else<span class="cov0" title="0"> {
                roundIDs, err = r.client.ZRevRange(r.ctx, federationKey, 0, -1).Result()
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get round list: %w", err)
        }</span>

        <span class="cov0" title="0">var rounds []RoundMetrics
        for _, id := range roundIDs </span><span class="cov0" title="0">{
                key := fmt.Sprintf("round:%s", id)

                data, err := r.client.Get(r.ctx, key).Result()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip failed rounds
                }

                <span class="cov0" title="0">var round RoundMetrics
                if err := json.Unmarshal([]byte(data), &amp;round); err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid data
                }

                <span class="cov0" title="0">rounds = append(rounds, round)</span>
        }

        <span class="cov0" title="0">return rounds, nil</span>
}

// StoreResourceMetrics stores resource metrics in Redis using time series
func (r *RedisStorage) StoreResourceMetrics(metrics ResourceMetrics) error <span class="cov0" title="0">{
        // Use Redis Streams for time series data
        streamKey := "resource_metrics:system" // Use a fixed key since SourceID is not available

        values := map[string]interface{}{
                "source_type":  "system",
                "cpu_usage":    metrics.CPUUsage,
                "memory_usage": metrics.MemoryUsage,
                "disk_usage":   metrics.DiskUsage,
                "network_rx":   metrics.NetworkRxRate,
                "network_tx":   metrics.NetworkTxRate,
                "timestamp":    metrics.Timestamp.Unix(),
        }

        if err := r.client.XAdd(r.ctx, &amp;redis.XAddArgs{
                Stream: streamKey,
                Values: values,
        }).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store resource metrics: %w", err)
        }</span>

        // Set TTL for the stream
        <span class="cov0" title="0">r.client.Expire(r.ctx, streamKey, r.getDefaultTTL())

        // Trim stream to keep only recent entries (last 1000 entries)
        r.client.XTrimMaxLen(r.ctx, streamKey, 1000)

        return nil</span>
}

// StoreEvent stores monitoring events in Redis
func (r *RedisStorage) StoreEvent(event MonitoringEvent) error <span class="cov0" title="0">{
        // Use Redis Streams for events
        streamKey := "events"
        if event.FederationID != "" </span><span class="cov0" title="0">{
                streamKey = fmt.Sprintf("events:%s", event.FederationID)
        }</span>

        <span class="cov0" title="0">dataJSON, err := json.Marshal(event.Data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal event data: %w", err)
        }</span>

        <span class="cov0" title="0">values := map[string]interface{}{
                "federation_id": event.FederationID,
                "type":          event.Type,
                "message":       event.Message,
                "level":         event.Level,
                "data":          string(dataJSON),
                "timestamp":     event.Timestamp.Unix(),
        }

        if err := r.client.XAdd(r.ctx, &amp;redis.XAddArgs{
                Stream: streamKey,
                Values: values,
        }).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store event: %w", err)
        }</span>

        // Set TTL for the stream
        <span class="cov0" title="0">r.client.Expire(r.ctx, streamKey, r.getDefaultTTL())

        // Trim stream to keep only recent entries (last 10000 events)
        r.client.XTrimMaxLen(r.ctx, streamKey, 10000)

        return nil</span>
}

// GetEvents retrieves monitoring events from Redis
func (r *RedisStorage) GetEvents(federationID string, limit int, offset int) ([]MonitoringEvent, error) <span class="cov0" title="0">{
        streamKey := "events"
        if federationID != "" </span><span class="cov0" title="0">{
                streamKey = fmt.Sprintf("events:%s", federationID)
        }</span>

        // Redis Streams don't support offset directly, so we'll get more and slice
        <span class="cov0" title="0">count := int64(limit + offset)
        if count &lt;= 0 </span><span class="cov0" title="0">{
                count = 100 // Default limit
        }</span>

        // Get events from stream (newest first)
        <span class="cov0" title="0">streams, err := r.client.XRevRangeN(r.ctx, streamKey, "+", "-", count).Result()
        if err != nil </span><span class="cov0" title="0">{
                if err == redis.Nil </span><span class="cov0" title="0">{
                        return []MonitoringEvent{}, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get events: %w", err)</span>
        }

        <span class="cov0" title="0">var events []MonitoringEvent

        // Apply offset
        start := offset
        if start &gt; len(streams) </span><span class="cov0" title="0">{
                return []MonitoringEvent{}, nil
        }</span>

        <span class="cov0" title="0">end := start + limit
        if end &gt; len(streams) </span><span class="cov0" title="0">{
                end = len(streams)
        }</span>

        <span class="cov0" title="0">for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                stream := streams[i]

                var event MonitoringEvent

                // Parse values from stream
                for field, value := range stream.Values </span><span class="cov0" title="0">{
                        switch field </span>{
                        case "federation_id":<span class="cov0" title="0">
                                if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        event.FederationID = str
                                }</span>
                        case "type":<span class="cov0" title="0">
                                if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        event.Type = MetricType(str)
                                }</span>
                        case "message":<span class="cov0" title="0">
                                if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        event.Message = str
                                }</span>
                        case "level":<span class="cov0" title="0">
                                if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        event.Level = str
                                }</span>
                        case "data":<span class="cov0" title="0">
                                if str, ok := value.(string); ok &amp;&amp; str != "" </span><span class="cov0" title="0">{
                                        var data map[string]interface{}
                                        if err := json.Unmarshal([]byte(str), &amp;data); err == nil </span><span class="cov0" title="0">{
                                                event.Data = data
                                        }</span>
                                }
                        case "timestamp":<span class="cov0" title="0">
                                if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        if timestamp, err := strconv.ParseInt(str, 10, 64); err == nil </span><span class="cov0" title="0">{
                                                event.Timestamp = time.Unix(timestamp, 0)
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">events = append(events, event)</span>
        }

        <span class="cov0" title="0">return events, nil</span>
}

// Close closes the Redis connection
func (r *RedisStorage) Close() error <span class="cov0" title="0">{
        return r.client.Close()
}</span>

// Cleanup removes old data from Redis
func (r *RedisStorage) Cleanup(maxAge time.Duration) error <span class="cov0" title="0">{
        cutoff := time.Now().Add(-maxAge).Unix()

        // Find all resource metric streams
        keys, err := r.client.Keys(r.ctx, "resource_metrics:*").Result()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find resource metric keys: %w", err)
        }</span>

        <span class="cov0" title="0">for _, key := range keys </span><span class="cov0" title="0">{
                // Remove old entries from streams
                if err := r.client.XTrimMinID(r.ctx, key, fmt.Sprintf("%d-0", cutoff)).Err(); err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip errors for individual streams
                }
        }

        // Find all event streams
        <span class="cov0" title="0">eventKeys, err := r.client.Keys(r.ctx, "events*").Result()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find event keys: %w", err)
        }</span>

        <span class="cov0" title="0">for _, key := range eventKeys </span><span class="cov0" title="0">{
                // Remove old entries from event streams
                if err := r.client.XTrimMinID(r.ctx, key, fmt.Sprintf("%d-0", cutoff)).Err(); err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip errors for individual streams
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// GetStats returns Redis storage statistics
func (r *RedisStorage) GetStats() (map[string]interface{}, error) <span class="cov0" title="0">{
        info, err := r.client.Info(r.ctx, "memory", "keyspace").Result()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get Redis info: %w", err)
        }</span>

        // Count keys
        <span class="cov0" title="0">federationCount, _ := r.client.SCard(r.ctx, "federations:list").Result()

        stats := map[string]interface{}{
                "storage_type":      "redis",
                "server_info":       info,
                "federation_count":  federationCount,
                "connection_status": "connected",
        }

        return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package security

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/tls"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/pem"
        "fmt"
        "math/big"
        "net"
        "os"
        "path/filepath"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"
        "google.golang.org/grpc/credentials/insecure"
)

// TLSConfig represents the TLS configuration for mTLS
type TLSConfig struct {
        Enabled          bool   `yaml:"enabled"`
        CertPath         string `yaml:"cert_path"`
        KeyPath          string `yaml:"key_path"`
        CAPath           string `yaml:"ca_path"`
        ServerName       string `yaml:"server_name"`
        InsecureSkipTLS  bool   `yaml:"insecure_skip_tls"` // For development only
        AutoGenerateCert bool   `yaml:"auto_generate_cert"`
}

// TLSManager handles TLS certificate generation and management
type TLSManager struct {
        config     TLSConfig
        certDir    string
        serverCert tls.Certificate
        clientCert tls.Certificate
        caCert     *x509.Certificate
}

// NewTLSManager creates a new TLS manager
func NewTLSManager(config TLSConfig, certDir string) (*TLSManager, error) <span class="cov8" title="1">{
        tm := &amp;TLSManager{
                config:  config,
                certDir: certDir,
        }

        if config.Enabled </span><span class="cov8" title="1">{
                if config.AutoGenerateCert </span><span class="cov8" title="1">{
                        if err := tm.generateCertificates(); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to generate certificates: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">if err := tm.loadCertificates(); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to load certificates: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return tm, nil</span>
}

// GetServerCredentials returns gRPC server credentials
func (tm *TLSManager) GetServerCredentials() (credentials.TransportCredentials, error) <span class="cov8" title="1">{
        if !tm.config.Enabled </span><span class="cov8" title="1">{
                return insecure.NewCredentials(), nil
        }</span>

        // Create TLS config for server
        <span class="cov8" title="1">tlsConfig := &amp;tls.Config{
                Certificates: []tls.Certificate{tm.serverCert},
                ClientAuth:   tls.RequireAndVerifyClientCert,
                ClientCAs:    tm.getCertPool(),
                MinVersion:   tls.VersionTLS12,
        }

        return credentials.NewTLS(tlsConfig), nil</span>
}

// GetClientCredentials returns gRPC client credentials
func (tm *TLSManager) GetClientCredentials() (credentials.TransportCredentials, error) <span class="cov8" title="1">{
        if !tm.config.Enabled </span><span class="cov8" title="1">{
                return insecure.NewCredentials(), nil
        }</span>

        // Create TLS config for client
        <span class="cov8" title="1">tlsConfig := &amp;tls.Config{
                Certificates: []tls.Certificate{tm.clientCert},
                RootCAs:      tm.getCertPool(),
                ServerName:   tm.config.ServerName,
                MinVersion:   tls.VersionTLS12,
        }

        if tm.config.InsecureSkipTLS </span><span class="cov8" title="1">{
                tlsConfig.InsecureSkipVerify = true
        }</span>

        <span class="cov8" title="1">return credentials.NewTLS(tlsConfig), nil</span>
}

// getCertPool returns the CA certificate pool
func (tm *TLSManager) getCertPool() *x509.CertPool <span class="cov8" title="1">{
        if tm.caCert == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">pool := x509.NewCertPool()
        pool.AddCert(tm.caCert)
        return pool</span>
}

// generateCertificates generates self-signed certificates for development
func (tm *TLSManager) generateCertificates() error <span class="cov8" title="1">{
        // Ensure certificate directory exists
        if err := os.MkdirAll(tm.certDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create cert directory: %w", err)
        }</span>

        // Generate CA certificate
        <span class="cov8" title="1">if err := tm.generateCACertificate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate CA certificate: %w", err)
        }</span>

        // Generate server certificate
        <span class="cov8" title="1">if err := tm.generateServerCertificate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate server certificate: %w", err)
        }</span>

        // Generate client certificate
        <span class="cov8" title="1">if err := tm.generateClientCertificate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate client certificate: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// generateCACertificate generates a CA certificate
func (tm *TLSManager) generateCACertificate() error <span class="cov8" title="1">{
        // Generate private key
        privKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create certificate template
        <span class="cov8" title="1">template := x509.Certificate{
                SerialNumber: big.NewInt(1),
                Subject: pkix.Name{
                        Organization:       []string{"FL-Go"},
                        OrganizationalUnit: []string{"Development"},
                        Country:            []string{"US"},
                        Province:           []string{""},
                        Locality:           []string{""},
                        CommonName:         "FL-Go CA",
                },
                NotBefore:             time.Now(),
                NotAfter:              time.Now().Add(365 * 24 * time.Hour), // 1 year
                KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
                ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth},
                BasicConstraintsValid: true,
                IsCA:                  true,
        }

        // Create certificate
        certDER, err := x509.CreateCertificate(rand.Reader, &amp;template, &amp;template, &amp;privKey.PublicKey, privKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Save certificate
        <span class="cov8" title="1">certOut, err := os.Create(filepath.Join(tm.certDir, "ca.crt"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer certOut.Close()

        if err := pem.Encode(certOut, &amp;pem.Block{Type: "CERTIFICATE", Bytes: certDER}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Save private key
        <span class="cov8" title="1">keyOut, err := os.Create(filepath.Join(tm.certDir, "ca.key"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer keyOut.Close()

        privKeyBytes, err := x509.MarshalPKCS8PrivateKey(privKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return pem.Encode(keyOut, &amp;pem.Block{Type: "PRIVATE KEY", Bytes: privKeyBytes})</span>
}

// generateServerCertificate generates a server certificate signed by the CA
func (tm *TLSManager) generateServerCertificate() error <span class="cov8" title="1">{
        // Load CA certificate and key
        caCert, caKey, err := tm.loadCACertificate()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Generate private key
        <span class="cov8" title="1">privKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create certificate template
        <span class="cov8" title="1">template := x509.Certificate{
                SerialNumber: big.NewInt(2),
                Subject: pkix.Name{
                        Organization:       []string{"FL-Go"},
                        OrganizationalUnit: []string{"Server"},
                        Country:            []string{"US"},
                        Province:           []string{""},
                        Locality:           []string{""},
                        CommonName:         "FL-Go Server",
                },
                NotBefore:   time.Now(),
                NotAfter:    time.Now().Add(365 * 24 * time.Hour), // 1 year
                KeyUsage:    x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
                ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
                IPAddresses: []net.IP{net.IPv4(127, 0, 0, 1), net.IPv6loopback},
                DNSNames:    []string{"localhost", "fl-go-server"},
        }

        // Create certificate
        certDER, err := x509.CreateCertificate(rand.Reader, &amp;template, caCert, &amp;privKey.PublicKey, caKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Save certificate
        <span class="cov8" title="1">certOut, err := os.Create(filepath.Join(tm.certDir, "server.crt"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer certOut.Close()

        if err := pem.Encode(certOut, &amp;pem.Block{Type: "CERTIFICATE", Bytes: certDER}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Save private key
        <span class="cov8" title="1">keyOut, err := os.Create(filepath.Join(tm.certDir, "server.key"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer keyOut.Close()

        privKeyBytes, err := x509.MarshalPKCS8PrivateKey(privKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return pem.Encode(keyOut, &amp;pem.Block{Type: "PRIVATE KEY", Bytes: privKeyBytes})</span>
}

// generateClientCertificate generates a client certificate signed by the CA
func (tm *TLSManager) generateClientCertificate() error <span class="cov8" title="1">{
        // Load CA certificate and key
        caCert, caKey, err := tm.loadCACertificate()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Generate private key
        <span class="cov8" title="1">privKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create certificate template
        <span class="cov8" title="1">template := x509.Certificate{
                SerialNumber: big.NewInt(3),
                Subject: pkix.Name{
                        Organization:       []string{"FL-Go"},
                        OrganizationalUnit: []string{"Client"},
                        Country:            []string{"US"},
                        Province:           []string{""},
                        Locality:           []string{""},
                        CommonName:         "FL-Go Client",
                },
                NotBefore:   time.Now(),
                NotAfter:    time.Now().Add(365 * 24 * time.Hour), // 1 year
                KeyUsage:    x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
                ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth},
        }

        // Create certificate
        certDER, err := x509.CreateCertificate(rand.Reader, &amp;template, caCert, &amp;privKey.PublicKey, caKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Save certificate
        <span class="cov8" title="1">certOut, err := os.Create(filepath.Join(tm.certDir, "client.crt"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer certOut.Close()

        if err := pem.Encode(certOut, &amp;pem.Block{Type: "CERTIFICATE", Bytes: certDER}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Save private key
        <span class="cov8" title="1">keyOut, err := os.Create(filepath.Join(tm.certDir, "client.key"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer keyOut.Close()

        privKeyBytes, err := x509.MarshalPKCS8PrivateKey(privKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return pem.Encode(keyOut, &amp;pem.Block{Type: "PRIVATE KEY", Bytes: privKeyBytes})</span>
}

// loadCACertificate loads the CA certificate and private key
func (tm *TLSManager) loadCACertificate() (*x509.Certificate, interface{}, error) <span class="cov8" title="1">{
        // Load certificate
        certPEM, err := os.ReadFile(filepath.Join(tm.certDir, "ca.crt"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">certBlock, _ := pem.Decode(certPEM)
        if certBlock == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to decode CA certificate")
        }</span>

        <span class="cov8" title="1">cert, err := x509.ParseCertificate(certBlock.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // Load private key
        <span class="cov8" title="1">keyPEM, err := os.ReadFile(filepath.Join(tm.certDir, "ca.key"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">keyBlock, _ := pem.Decode(keyPEM)
        if keyBlock == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to decode CA private key")
        }</span>

        <span class="cov8" title="1">key, err := x509.ParsePKCS8PrivateKey(keyBlock.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">return cert, key, nil</span>
}

// loadCertificates loads the TLS certificates for server and client
func (tm *TLSManager) loadCertificates() error <span class="cov8" title="1">{
        // Load CA certificate
        caCertPath := tm.config.CAPath
        if caCertPath == "" </span><span class="cov8" title="1">{
                caCertPath = filepath.Join(tm.certDir, "ca.crt")
        }</span>

        <span class="cov8" title="1">caCertPEM, err := os.ReadFile(caCertPath)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to read CA certificate: %w", err)
        }</span>

        <span class="cov8" title="1">caCertBlock, _ := pem.Decode(caCertPEM)
        if caCertBlock == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode CA certificate")
        }</span>

        <span class="cov8" title="1">tm.caCert, err = x509.ParseCertificate(caCertBlock.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse CA certificate: %w", err)
        }</span>

        // Load server certificate
        <span class="cov8" title="1">serverCertPath := tm.config.CertPath
        serverKeyPath := tm.config.KeyPath
        if serverCertPath == "" </span><span class="cov8" title="1">{
                serverCertPath = filepath.Join(tm.certDir, "server.crt")
        }</span>
        <span class="cov8" title="1">if serverKeyPath == "" </span><span class="cov8" title="1">{
                serverKeyPath = filepath.Join(tm.certDir, "server.key")
        }</span>

        <span class="cov8" title="1">tm.serverCert, err = tls.LoadX509KeyPair(serverCertPath, serverKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load server certificate: %w", err)
        }</span>

        // Load client certificate
        <span class="cov8" title="1">clientCertPath := filepath.Join(tm.certDir, "client.crt")
        clientKeyPath := filepath.Join(tm.certDir, "client.key")

        tm.clientCert, err = tls.LoadX509KeyPair(clientCertPath, clientKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load client certificate: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// NewServerOptions returns gRPC server options with mTLS
func (tm *TLSManager) NewServerOptions() ([]grpc.ServerOption, error) <span class="cov8" title="1">{
        creds, err := tm.GetServerCredentials()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return []grpc.ServerOption{grpc.Creds(creds)}, nil</span>
}

// NewClientDialOptions returns gRPC client dial options with mTLS
func (tm *TLSManager) NewClientDialOptions() ([]grpc.DialOption, error) <span class="cov8" title="1">{
        creds, err := tm.GetClientCredentials()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return []grpc.DialOption{grpc.WithTransportCredentials(creds)}, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
